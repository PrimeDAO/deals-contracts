{
  "language": "Solidity",
  "sources": {
    "contracts/BaseContract.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/IDepositContract.sol\";\nimport \"./interfaces/IModuleBase.sol\";\n\n/**\n * @title PrimeDeals Base Contract\n * @dev   Smart contract to serve as the base\n          of the PrimeDeals architecture\n */\ncontract BaseContract is Ownable {\n    // address of the current implementation of the\n    // deposit contract\n    address public depositContractImplementation;\n\n    // address of the eth wrapping contract\n    address public weth;\n\n    // address DAO => address deposit contract of the DAO\n    mapping(address => address) public depositContract;\n\n    // address DAO => address representative => true/false\n    mapping(address => mapping(address => bool)) public representative;\n\n    // the module identifier (bytes32) is e.g.\n    // keccak256(abi.encode(TOKEN_SWAP_MODULE))\n    mapping(bytes32 => address[]) public modules;\n\n    // module address => true/false\n    mapping(address => bool) public isModule;\n\n    event DepositContractCreated(address dao, address depositContract);\n\n    event RepresentativeStatusChanged(\n        address dao,\n        address representative,\n        bool status\n    );\n\n    // Sets a new address for the deposit contract implementation\n    function setDepositContractImplementation(address _newImplementation)\n        external\n        onlyOwner\n    {\n        // solhint-disable-next-line reason-string\n        require(\n            _newImplementation != address(0),\n            \"BASECONTRACT-INVALID-IMPLEMENTATION-ADDRESS\"\n        );\n        depositContractImplementation = _newImplementation;\n    }\n\n    // Sets a new address for the deposit contract implementation\n    function setWETHAddress(address _newWETH) external onlyOwner {\n        // solhint-disable-next-line reason-string\n        require(_newWETH != address(0), \"BASECONTRACT-INVALID-WETH-ADDRESS\");\n        weth = _newWETH;\n    }\n\n    // Registers a new module\n    function registerModule(address _moduleAddress) external onlyOwner {\n        // solhint-disable-next-line reason-string\n        require(\n            _moduleAddress != address(0),\n            \"BASECONTRACT-INVALID-MODULE-ADDRESS\"\n        );\n        // solhint-disable-next-line reason-string\n        require(\n            IModuleBase(_moduleAddress).baseContract() == address(this),\n            \"BASECONTRACT-MODULE-SETUP-INVALID\"\n        );\n\n        modules[IModuleBase(_moduleAddress).moduleIdentifier()].push(\n            _moduleAddress\n        );\n\n        isModule[_moduleAddress] = true;\n    }\n\n    // Deactivates a module\n    function deactivateModule(address _moduleAddress) external onlyOwner {\n        // solhint-disable-next-line reason-string\n        require(\n            _moduleAddress != address(0),\n            \"BASECONTRACT-INVALID-MODULE-ADDRESS\"\n        );\n\n        isModule[_moduleAddress] = false;\n    }\n\n    // Retrieves the address of the latest module by its identifier\n    function getLatestModule(string calldata _module)\n        external\n        view\n        returns (address)\n    {\n        return\n            modules[keccak256(abi.encode(_module))][\n                modules[keccak256(abi.encode(_module))].length - 1\n            ];\n    }\n\n    // Marks an address as a representative of a dao\n    function setRepresentative(\n        address _dao,\n        address _representative,\n        bool _active\n    ) public onlyDAOorOwner(_dao) {\n        representative[_dao][_representative] = _active;\n        emit RepresentativeStatusChanged(_dao, _representative, _active);\n    }\n\n    // Marks addresses as representatives of a dao\n    function setRepresentatives(\n        address _dao,\n        address[] calldata _representatives,\n        bool[] calldata _active\n    ) external onlyDAOorOwner(_dao) {\n        // solhint-disable-next-line reason-string\n        require(\n            _representatives.length == _active.length,\n            \"BASECONTRACT-INVALID-ARRAY-LENGTH\"\n        );\n        for (uint256 i = 0; i < _representatives.length; i++) {\n            setRepresentative(_dao, _representatives[i], _active[i]);\n        }\n    }\n\n    // Creates a deposit contract for a DAO\n    function createDepositContract(address _dao) external {\n        require(_dao != address(0), \"BASECONTRACT-INVALID-DAO-ADDRESS\");\n        // solhint-disable-next-line reason-string\n        require(\n            depositContract[_dao] == address(0),\n            \"BASECONTRACT-DEPOSIT-CONTRACT-ALREADY-EXISTS\"\n        );\n        // solhint-disable-next-line reason-string\n        require(\n            depositContractImplementation != address(0),\n            \"BASECONTRACT-DEPOSIT-CONTRACT-IMPLEMENTATION-IS-NOT-SET\"\n        );\n        address newContract = Clones.clone(depositContractImplementation);\n        IDepositContract(newContract).initialize(_dao);\n        depositContract[_dao] = newContract;\n        emit DepositContractCreated(_dao, newContract);\n    }\n\n    // Returns whether a DAO already has a deposit contract\n    function hasDepositContract(address _dao) public view returns (bool) {\n        return getDepositContract(_dao) != address(0) ? true : false;\n    }\n\n    // Returns the deposit contract of a DAO\n    function getDepositContract(address _dao) public view returns (address) {\n        return depositContract[_dao];\n    }\n\n    // Returns whether the address is the DAO, a representative or\n    // the contract owner\n    function isDAOorOwner(address _caller, address _dao)\n        public\n        view\n        returns (bool)\n    {\n        // If caller is the contract owner, or...\n        if (_caller == owner()) {\n            return true;\n        }\n        // If caller is the DAO, or..\n        if (_caller == _dao && hasDepositContract(_dao)) {\n            return true;\n        }\n        // If caller is a representative of the dao\n        if (representative[_dao][_caller]) {\n            return true;\n        }\n        // Rest: not DAO, DAOplomat or Owner -> false\n        return false;\n    }\n\n    // Returns whether the address is the DAO or a representative of\n    // a DAO from an array of DAOs or the contract owner.\n    function isDAOorOwnerFromArray(\n        address _caller,\n        address[] memory _involvedDAOs\n    ) public view returns (bool) {\n        // If caller is the contract owner, or...\n        if (_caller == owner()) {\n            return true;\n        }\n        for (uint256 i = 0; i < _involvedDAOs.length; i++) {\n            // If caller is one of the registered DAOs, or..\n            if (\n                _caller == _involvedDAOs[i] &&\n                hasDepositContract(_involvedDAOs[i])\n            ) {\n                return true;\n            }\n            // If caller is a representative of one of the daos\n            if (representative[_involvedDAOs[i]][_caller]) {\n                return true;\n            }\n        }\n        // Rest: not DAO, DAOplomat or Owner -> false\n        return false;\n    }\n\n    modifier onlyDAOorOwner(address _dao) {\n        require(isDAOorOwner(msg.sender, _dao), \"BASECONTRACT-NOT-AUTHROIZED\");\n        _;\n    }\n\n    function addressIsModule(address _address) public view returns (bool) {\n        return isModule[_address];\n    }\n\n    modifier onlyModule() {\n        // solhint-disable-next-line reason-string\n        require(\n            addressIsModule(msg.sender),\n            \"BASECONTRACT-CAN-ONLY-BE-CALLED-BY-MODULE\"\n        );\n        _;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/interfaces/IDepositContract.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.9;\n\ninterface IDepositContract {\n    function initialize(address _dao) external;\n\n    function migrateBaseContract(address _newBaseContract) external;\n\n    function deposit(\n        bytes32 _processID,\n        address _token,\n        uint256 _amount\n    ) external payable;\n\n    function multipleDeposits(\n        bytes32 _processID,\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    ) external payable;\n\n    function registerDeposit(bytes32 _processID, address _token) external;\n\n    function registerDeposits(bytes32 _processID, address[] calldata _tokens)\n        external;\n\n    function withdraw(\n        bytes32 _processID,\n        uint256 _depositID,\n        address _sender\n    )\n        external\n        returns (\n            address,\n            address,\n            uint256\n        );\n\n    function sendToModule(\n        bytes32 _processID,\n        address _token,\n        uint256 _amount\n    ) external returns (bool);\n\n    function startVesting(\n        address _token,\n        uint256 _amount,\n        uint256 _start,\n        uint256 _end\n    ) external;\n\n    function claimVestings() external;\n\n    function verifyBalance(address _token) external view;\n\n    function getDeposit(bytes32 _processID, uint256 _depositID)\n        external\n        view\n        returns (\n            address,\n            address,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function getAvailableProcessBalance(bytes32 _processID, address _token)\n        external\n        view\n        returns (uint256);\n\n    function getTotalDepositCount(bytes32 _processID)\n        external\n        view\n        returns (uint256);\n\n    function getWithdrawableAmountOfUser(\n        bytes32 _processID,\n        address _user,\n        address _token\n    ) external view returns (uint256);\n\n    function getBalance(address _token) external view returns (uint256);\n\n    function getVestedBalance(address _token) external view returns (uint256);\n\n    function getProcessID(string memory _module, uint256 _id)\n        external\n        pure\n        returns (bytes32);\n}\n"
    },
    "contracts/interfaces/IModuleBase.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.9;\n\ninterface IModuleBase {\n    function moduleIdentifier() external view returns (bytes32);\n\n    function baseContract() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/modules/ModuleBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IDepositContract.sol\";\nimport \"../interfaces/IBaseContract.sol\";\n\n/**\n * @title PrimeDeals Module Base\n * @dev   Smart contract to serve as the\n          basis for each module\n */\ncontract ModuleBase {\n    // String of the unique module identifier\n    // e.g. TOKEN_SWAP_MODULE\n    string public moduleIdentifierString;\n\n    // keccak256 of the identifier string\n    bytes32 public moduleIdentifier;\n\n    IBaseContract public baseContract;\n\n    enum Status {\n        NULL,\n        ACTIVE,\n        CANCELLED,\n        DONE\n    }\n\n    constructor(address _baseContract, string memory _moduleIdentifier) {\n        require(\n            _baseContract != address(0),\n            \"Module: invalid base contract address\"\n        );\n        baseContract = IBaseContract(_baseContract);\n        require(\n            bytes(_moduleIdentifier).length > 0,\n            \"Module: module identifier invalid\"\n        );\n        moduleIdentifierString = _moduleIdentifier;\n        moduleIdentifier = keccak256(abi.encode(moduleIdentifierString));\n    }\n\n    /**\n      * @dev                Sends tokens from a deposit contract to the module\n      * @param _id          ID of the action this is related to\n      * @param _daos        Array containing the DAOs that are involed in this action\n      * @param _tokens      Array containing the tokens that are involed in this action\n      * @param _path        Double nested array containing the amounts of tokens for each\n                            token for each dao to be send\n      * @return amountsIn   Array containing the total amounts sent per token\n    */\n    function _pullTokensIntoModule(\n        uint256 _id,\n        address[] memory _daos,\n        address[] memory _tokens,\n        uint256[][] memory _path\n    ) internal returns (uint256[] memory amountsIn) {\n        amountsIn = new uint256[](_tokens.length);\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            require(_path[i].length == _daos.length, \"asd\");\n            for (uint256 j = 0; j < _path[i].length; j++) {\n                if (_path[i][j] > 0) {\n                    amountsIn[i] += _path[i][j];\n                    IDepositContract(baseContract.getDepositContract(_daos[j]))\n                        .sendToModule(\n                            keccak256(abi.encode(moduleIdentifierString, _id)),\n                            _tokens[i],\n                            _path[i][j]\n                        );\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev            Calls the approval function of a token\n     * @param _token   Address of the token\n     * @param _to      Target of the approval\n     * @param _amount  Amount to be approved\n     */\n    function _approveToken(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) internal {\n        require(IERC20(_token).approve(_to, _amount), \"Module: approve failed\");\n    }\n\n    /**\n     * @dev            Calls the approval function of a token\n                       for the deposit contract of a DAO\n     * @param _token   Address of the token\n     * @param _dao     DAO whose deposit contract is the target\n     * @param _amount  Amount to be approved\n     */\n    function _approveDepositContract(\n        address _token,\n        address _dao,\n        uint256 _amount\n    ) internal {\n        _approveToken(_token, baseContract.getDepositContract(_dao), _amount);\n    }\n\n    /**\n     * @dev            Transfers an amount of tokens\n     * @param _token   Address of the token\n     * @param _to      Target of the transfer\n     * @param _amount  Amount to be sent\n     */\n    function _transferToken(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) internal {\n        require(\n            IERC20(_token).transfer(_to, _amount),\n            \"Module: transfer failed\"\n        );\n    }\n\n    /**\n     * @dev            Transfers an amount of tokens from an address\n     * @param _token   Address of the token\n     * @param _from    Source of the transfer\n     * @param _to      Target of the transfer\n     * @param _amount  Amount to be sent\n     */\n    function _transferFromToken(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        require(\n            IERC20(_token).transferFrom(_from, _to, _amount),\n            \"Module: transfer from failed\"\n        );\n    }\n}\n"
    },
    "contracts/interfaces/IBaseContract.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.9;\n\ninterface IBaseContract {\n    function createDepositContract(address _dao) external;\n\n    function hasDepositContract(address _dao) external view returns (bool);\n\n    function getDepositContract(address _dao) external view returns (address);\n\n    function isDAOorOwner(address _caller, address _dao)\n        external\n        view\n        returns (bool);\n\n    function isDAOorOwnerFromArray(\n        address _caller,\n        address[] calldata _involvedDAOs\n    ) external view returns (bool);\n\n    function owner() external view returns (address);\n\n    function weth() external view returns (address);\n\n    function addressIsModule(address _address) external view returns (bool);\n}\n"
    },
    "contracts/modules/ModuleBaseWithFee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.9;\n\nimport \"./ModuleBase.sol\";\n\n/**\n * @title PrimeDeals Module Base Fee Extension\n * @dev   Smart contract to extend the module\n          base with a fee mechanim\n */\ncontract ModuleBaseWithFee is ModuleBase {\n    // Wallet that is receiving the fees\n    address public feeWallet;\n    // Fee in basis points (1% = 10000)\n    uint256 public feeInBasisPoints;\n\n    constructor(address _baseContract, string memory _moduleIdentifier)\n        ModuleBase(_baseContract, _moduleIdentifier)\n    {}\n\n    event FeeWalletChanged(address oldFeeWallet, address newFeeWallet);\n\n    event FeeChanged(uint256 oldFee, uint256 newFee);\n\n    /**\n     * @dev                 Sets a new fee wallet\n     * @param _feeWallet    Address of the new fee wallet\n     */\n    function setFeeWallet(address _feeWallet) external {\n        require(msg.sender == baseContract.owner(), \"Fee: not authorized\");\n        emit FeeWalletChanged(feeWallet, _feeWallet);\n        feeWallet = _feeWallet;\n    }\n\n    /**\n     * @dev                         Sets a new fee\n     * @param _feeInBasisPoints     Fee amount in basis points (1% = 10000)\n     */\n    function setFee(uint256 _feeInBasisPoints) external {\n        require(msg.sender == baseContract.owner(), \"Fee: not authorized\");\n        require(_feeInBasisPoints <= 10000, \"Fee: can't be more than 100%\");\n        emit FeeChanged(feeInBasisPoints, _feeInBasisPoints);\n        feeInBasisPoints = _feeInBasisPoints;\n    }\n\n    /**\n     * @dev             Pays the fee in a token and returns the remainder\n     * @param _token    Token in which the transfer happens\n     * @param _amount   Amount of the transfer\n     * @return          Remaining amount after the fee payment\n     */\n    function _payFeeAndReturnRemainder(address _token, uint256 _amount)\n        internal\n        returns (uint256)\n    {\n        if (feeWallet != address(0) && feeInBasisPoints > 0) {\n            uint256 fee = (_amount * feeInBasisPoints) / 10000;\n            _transferToken(_token, feeWallet, fee);\n\n            return _amount - fee;\n        }\n        return _amount;\n    }\n\n    /**\n     * @dev             Transfers a token amount with automated fee payment\n     * @param _token    Token in which the transfer happens\n     * @param _to       Target of the transfer\n     * @param _amount   Amount of the transfer\n     */\n    function _transferTokenWithFee(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) internal {\n        _transferToken(_token, _to, _payFeeAndReturnRemainder(_token, _amount));\n    }\n\n    /**\n     * @dev             Transfers a token amount from someone with \n                        automated fee payment\n     * @param _token    Token in which the transfer happens\n     * @param _from     Source of the transfer\n     * @param _to       Target of the transfer\n     * @param _amount   Amount of the transfer\n     */\n    function _transferFromTokenWithFee(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        _transferFromToken(\n            _token,\n            _from,\n            _to,\n            _payFeeAndReturnRemainder(_token, _amount)\n        );\n    }\n}\n"
    },
    "contracts/modules/tokenswap/TokenSwapModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.9;\n\nimport \"../ModuleBaseWithFee.sol\";\n\n/**\n * @title PrimeDeals Token Swap Module\n * @dev   Smart contract to handle token swap\n *        interactions for PrimeDeals\n */\ncontract TokenSwapModule is ModuleBaseWithFee {\n    TokenSwap[] public tokenSwaps;\n\n    struct TokenSwap {\n        // the participating DAOs\n        address[] daos;\n        // the tokens involved in the swap\n        address[] tokens;\n        // the token flow from the DAOs to the module\n        uint256[][] pathFrom;\n        // the token flow from the module to the DAO\n        uint256[][] pathTo;\n        // unix timestamp of the deadline\n        uint256 deadline;\n        // unix timestamp of the execution\n        uint256 executionDate;\n        // status of the deal\n        Status status;\n    }\n\n    // pathFrom:\n    // how much tokens does each dao send to the module\n    // token -> dao -> amount\n    // [[123, 0, 123], [0, 123, 0]]\n    // token 1: dao 1 sends 123, dao 2 sends 0, dao 3 sends 123, etc.\n\n    // pathTo:\n    // how much tokens does each dao receive from the module\n    // includes vesting\n    // token -> dao -> tuple(4)\n    // for each DAO there is a tuple of four values:\n    // instant amount, vested amount, vesting start, vesting end\n    // which then makes this array look like:\n    // [[instantAmount_dao1, vestedAmount_dao1, vestingStart_dao1,\n    // vestingEnd_dao1, instantAmount_dao2, ...], [...]]\n\n    event TokenSwapCreated(\n        uint256 indexed id,\n        address[] daos,\n        address[] tokens,\n        uint256[][] pathFrom,\n        uint256[][] pathTo,\n        uint256 deadline\n    );\n\n    event TokenSwapCancelled(uint256 indexed id);\n\n    event TokenSwapDeadlineExtended(uint256 indexed id, uint256 newDeadline);\n\n    event TokenSwapExecuted(uint256 indexed id);\n\n    constructor(address _baseContract)\n        ModuleBaseWithFee(_baseContract, \"TOKEN_SWAP_MODULE\")\n    {}\n\n    /**\n      * @dev                Create a new token swap action\n      * @param _daos        Array containing the DAOs that are involed in this action\n      * @param _tokens      Array containing the tokens that are involed in this action\n      * @param _pathFrom    Two-dimensional array containing the tokens flowing from the\n                            DAOs into the module:\n                              - First array level is for each token\n                              - Second array level is for each dao\n                              - Contains absolute numbers of tokens\n      * @param _pathTo      Two-dimensional array containing the tokens flowing from the\n                            module to the DAOs:\n                              - First array level is for each token\n                              - Second array level is for each dao\n                              - Contains a tuple(4) consisting of instant amount, vested \n                                amount, vesting start, vesting end which then makes this \n                                array look like:\n                                [[instantAmount_dao1, vestedAmount_dao1, vestingStart_dao1,\n                                vestingEnd_dao1, instantAmount_dao2, ...], [...]]\n      * @param _deadline    Time until which this action can be executed (unix timestamp)\n      * @return             The ID of the new action\n    */\n    function createSwap(\n        address[] calldata _daos,\n        address[] calldata _tokens,\n        uint256[][] calldata _pathFrom,\n        uint256[][] calldata _pathTo,\n        uint256 _deadline\n    ) public returns (uint256) {\n        require(\n            baseContract.isDAOorOwnerFromArray(msg.sender, _daos),\n            \"Module: not authorized\"\n        );\n        require(_daos.length >= 2, \"Module: at least 2 daos required\");\n        require(_tokens.length >= 1, \"Module: at least 1 token required\");\n        require(\n            _tokens.length == _pathFrom.length &&\n                _pathFrom.length == _pathTo.length &&\n                _pathFrom[0].length == _daos.length &&\n                _pathTo[0].length / 4 == _daos.length,\n            \"Module: invalid array lengths\"\n        );\n\n        TokenSwap memory ts = TokenSwap(\n            _daos,\n            _tokens,\n            _pathFrom,\n            _pathTo,\n            _deadline,\n            0,\n            Status.ACTIVE\n        );\n        tokenSwaps.push(ts);\n\n        emit TokenSwapCreated(\n            tokenSwaps.length - 1,\n            _daos,\n            _tokens,\n            _pathFrom,\n            _pathTo,\n            _deadline\n        );\n\n        return tokenSwaps.length - 1;\n    }\n\n    /**\n      * @dev                Create a new token swap action and automatically\n                            creates Deposit Contracts for each DAO that does not have one\n      * @param _daos        Array containing the DAOs that are involed in this action\n      * @param _tokens      Array containing the tokens that are involed in this action\n      * @param _pathFrom    Two-dimensional array containing the tokens flowing from the\n                            DAOs into the module:\n                              - First array level is for each token\n                              - Second array level is for each dao\n                              - Contains absolute numbers of tokens\n      * @param _pathTo      Two-dimensional array containing the tokens flowing from the\n                            module to the DAOs:\n                              - First array level is for each token\n                              - Second array level is for each dao\n                              - Contains a tuple(4) consisting of instant amount, vested \n                                amount, vesting start, vesting end which then makes this \n                                array look like:\n                                [[instantAmount_dao1, vestedAmount_dao1, vestingStart_dao1,\n                                vestingEnd_dao1, instantAmount_dao2, ...], [...]]\n      * @param _deadline    Time until which this action can be executed (unix timestamp)\n      * @return             The ID of the new action\n    */\n    function createDepositContractAndCreateSwap(\n        address[] calldata _daos,\n        address[] calldata _tokens,\n        uint256[][] calldata _pathFrom,\n        uint256[][] calldata _pathTo,\n        uint256 _deadline\n    ) external returns (uint256) {\n        for (uint256 i = 0; i < _daos.length; i++) {\n            if (!baseContract.hasDepositContract(_daos[i])) {\n                baseContract.createDepositContract(_daos[i]);\n            }\n        }\n\n        return createSwap(_daos, _tokens, _pathFrom, _pathTo, _deadline);\n    }\n\n    /**\n     * @dev        Cancels a token swap action\n     * @param _id  The ID of the action (position in the array)\n     */\n    function cancelSwap(uint256 _id)\n        external\n        validId(_id)\n        authorized(_id)\n        activeStatus(_id)\n    {\n        tokenSwaps[_id].status = Status.CANCELLED;\n        emit TokenSwapCancelled(_id);\n    }\n\n    /**\n      * @dev            Cancels a token swap action\n      * @param _id      The ID of the action (position in the array)\n      * @param _amount  Amount of seconds that the current deadline will be pushed\n                        back by\n    */\n    function extendDeadline(uint256 _id, uint256 _amount)\n        external\n        validId(_id)\n        authorized(_id)\n        activeStatus(_id)\n    {\n        uint256 newDeadline = tokenSwaps[_id].deadline + _amount;\n        require(\n            newDeadline > block.timestamp,\n            \"Module: new deadline is in the past\"\n        );\n\n        tokenSwaps[_id].deadline = newDeadline;\n\n        emit TokenSwapDeadlineExtended(_id, newDeadline);\n    }\n\n    /**\n      * @dev            Checks whether a token swap action can be executed\n                        (which is the case if all DAOs have deposited)\n      * @param _id      The ID of the action (position in the array)\n      * @return         A bool flag indiciating whether the action can be executed\n    */\n    function checkExecutability(uint256 _id)\n        external\n        view\n        validId(_id)\n        returns (bool)\n    {\n        TokenSwap memory ts = tokenSwaps[_id];\n        if (ts.status != Status.ACTIVE) {\n            return false;\n        }\n        if (ts.deadline < block.timestamp) {\n            return false;\n        }\n        for (uint256 i = 0; i < ts.tokens.length; i++) {\n            for (uint256 j = 0; j < ts.pathFrom[i].length; j++) {\n                // for each token and each pathFrom entry for this\n                // token, check whether the corresponding DAO\n                // has deposited the corresponding amount into their\n                // deposit contract\n                if (\n                    IDepositContract(\n                        baseContract.getDepositContract(ts.daos[j])\n                    ).getAvailableProcessBalance(\n                            keccak256(abi.encode(moduleIdentifierString, _id)),\n                            ts.tokens[i]\n                        ) < ts.pathFrom[i][j]\n                ) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev            Executes a token swap action\n     * @param _id      The ID of the action (position in the array)\n     */\n    function executeSwap(uint256 _id)\n        external\n        validId(_id)\n        activeStatus(_id)\n        authorized(_id)\n    {\n        TokenSwap memory ts = tokenSwaps[_id];\n\n        require(ts.deadline >= block.timestamp, \"Module: swap expired\");\n\n        // transfer the tokens from the deposit contract of the DAOs\n        // into this module\n        uint256[] memory amountsIn = _pullTokensIntoModule(\n            _id,\n            ts.daos,\n            ts.tokens,\n            ts.pathFrom\n        );\n\n        // distribute the tokens from this module to the DAOs\n        // and (if applicable) and their vesting contracts\n        uint256[] memory amountsOut = _distributeTokens(ts);\n\n        // verify whether the amounts being pulled and pushed match\n        for (uint256 i = 0; i < ts.tokens.length; i++) {\n            require(amountsIn[i] == amountsOut[i], \"Module: amount mismatch\");\n        }\n\n        ts.status = Status.DONE;\n        ts.executionDate = block.timestamp;\n        emit TokenSwapExecuted(_id);\n    }\n\n    /**\n      * @dev                Distributes the tokens based on the supplied\n                            information to the DAOs or their vesting contracts\n      * @param _ts          TokenSwap object containing all the information\n                            of the action\n      * @return amountsOut  The two min values for the token amounts _ts\n    */\n    function _distributeTokens(TokenSwap memory _ts)\n        internal\n        returns (uint256[] memory amountsOut)\n    {\n        amountsOut = new uint256[](_ts.tokens.length);\n        // Distribute tokens from the module\n        for (uint256 i = 0; i < _ts.tokens.length; i++) {\n            for (uint256 k = 0; k < _ts.pathTo[i].length / 4; k++) {\n                // every 4 values, the values for a new dao start\n                // value 0 = instant amount\n                // value 1 = vested amount\n                // value 2 = vesting start\n                // value 3 = vesting end\n                if (_ts.pathTo[i][k * 4] > 0) {\n                    amountsOut[i] += _ts.pathTo[i][k * 4];\n                    _transferTokenWithFee(\n                        _ts.tokens[i],\n                        _ts.daos[k],\n                        _ts.pathTo[i][k * 4]\n                    );\n                }\n                if (_ts.pathTo[i][k * 4 + 1] > 0) {\n                    amountsOut[i] += _ts.pathTo[i][k * 4 + 1];\n                    uint256 amount = _payFeeAndReturnRemainder(\n                        _ts.tokens[i],\n                        _ts.pathTo[i][k * 4 + 1]\n                    );\n                    _approveDepositContract(_ts.tokens[i], _ts.daos[k], amount);\n                    IDepositContract(\n                        baseContract.getDepositContract(_ts.daos[k])\n                    ).startVesting(\n                            _ts.tokens[i],\n                            amount, // amount\n                            _ts.pathTo[i][k * 4 + 2], // start\n                            _ts.pathTo[i][k * 4 + 3] // end\n                        );\n                }\n            }\n        }\n    }\n\n    modifier validId(uint256 _id) {\n        require(_id <= tokenSwaps.length, \"Module: id doesn't exist\");\n        _;\n    }\n\n    modifier activeStatus(uint256 _id) {\n        require(\n            tokenSwaps[_id].status == Status.ACTIVE,\n            \"Module: id not active\"\n        );\n        _;\n    }\n\n    modifier authorized(uint256 _id) {\n        require(\n            baseContract.isDAOorOwnerFromArray(\n                msg.sender,\n                tokenSwaps[_id].daos\n            ),\n            \"Module: not authorized\"\n        );\n        _;\n    }\n}\n"
    },
    "contracts/modules/liquidity/uniswap/LiquidityModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.9;\n\nimport \"../../ModuleBaseWithFee.sol\";\nimport \"../../../interfaces/IUniswapV2Router02.sol\";\nimport \"../../../interfaces/IUniswapV2Factory.sol\";\n\n/**\n * @title PrimeDeals Liquidity Module (Uniswap)\n * @dev   Smart contract to handle liquidity pool\n *        interactions for PrimeDeals\n */\ncontract LiquidityModule_Uniswap is ModuleBaseWithFee {\n    IUniswapV2Router02 public router;\n    IUniswapV2Factory public factory;\n\n    LiquidityAction[] public liquidityActions;\n\n    struct LiquidityAction {\n        // the participating DAOs\n        address[] daos;\n        // the tokens involved in the action\n        address[] tokens;\n        // the token flow from the DAOs to the module\n        uint256[][] pathFrom;\n        // the lp token flow from the module to the DAO\n        uint256[] pathTo;\n        // the maximum difference between the\n        // token ratio from pathFrom and the\n        // actual ratio on-chain in basis points\n        // (1% = 10000)\n        uint256 maxDiff;\n        // unix timestamp of the deadline\n        uint256 deadline;\n        // unix timestamp of the execution\n        uint256 executionDate;\n        // status of the deal\n        Status status;\n    }\n\n    // pathFrom:\n    // how much tokens does each dao send to the module\n    // token -> dao -> amount\n    // [[123, 0, 123], [0, 123, 0]]\n    // token 1: dao 1 sends 123, dao 2 sends 0, dao 3 sends 123, etc.\n\n    // pathFrom:\n    // how much lp tokens does each dao receive\n    // from the module, includes vesting.\n    // since we do not know the amount of the LP tokens in any case\n    // we use percentage values here in basis points, so\n    // 100% = 1000000\n    // token -> dao -> tuple(4)\n    // [[instantAmount_dao1, vestedAmount_dao1, vestingStart_dao1,\n    // vestingEnd_dao1, instantAmount_dao2, ...], [...]]\n\n    event LiquidityActionCreated(\n        uint256 id,\n        address[] _daos,\n        address[] _tokens,\n        uint256[][] _pathFrom,\n        uint256[] _pathTo,\n        uint256 _maxDiff,\n        uint256 _deadline\n    );\n\n    event LiquidityActionCancelled(uint256 id);\n\n    event LiquidityActionDeadlineExtended(uint256 id, uint256 newDeadline);\n\n    event LiquidityActionExecuted(uint256 id);\n\n    constructor(address _baseContract, address _router)\n        ModuleBaseWithFee(_baseContract, \"UNISWAP_LIQUIDITY_MODULE\")\n    {\n        require(_router != address(0), \"Module: invalid router address\");\n        router = IUniswapV2Router02(_router);\n        factory = IUniswapV2Factory(router.factory());\n    }\n\n    /**\n      * @dev                Create a new liquidity pool related action\n      * @param _daos        Array containing the DAOs that are involed in this action\n      * @param _tokens      Array containing the tokens that are involed in this action\n      * @param _pathFrom    Two-dimensional array containing the tokens flowing from the\n                            DAOs into the module:\n                              - First array level is for each token\n                              - Second array level is for each dao\n                              - Contains absolute numbers of tokens\n      * @param _pathTo      Array containing the resulting LP tokens flowing to the DAOs\n                              - Contains percentage numbers of tokens\n                              - In Basis Points (1% = 10000) \n      * @param _maxDiff     The maximum difference between the ratio resulting from the \n                            pathFrom and the actual balance of the pool (if it already \n                            exists)\n                              - In Basis Points (1% = 10000) \n      * @param _deadline    Time until which this action can be executed (unix timestamp)\n      * @return             The ID of the new action\n    */\n    function createLiquidityAction(\n        address[] calldata _daos,\n        address[] calldata _tokens,\n        uint256[][] calldata _pathFrom,\n        uint256[] calldata _pathTo,\n        uint256 _maxDiff,\n        uint256 _deadline\n    ) public returns (uint256) {\n        require(\n            baseContract.isDAOorOwnerFromArray(msg.sender, _daos),\n            \"Module: not authorized\"\n        );\n        require(_daos.length >= 2, \"Module: at least 2 daos required\");\n\n        require(\n            _tokens.length == 2,\n            \"Module: only exactly two tokens supported\"\n        );\n\n        require(_maxDiff <= 10000, \"Module: maxDiff can't be more than 100%\");\n\n        require(\n            _pathFrom.length == _pathTo.length &&\n                _pathFrom[0].length == _daos.length &&\n                _pathTo.length / 4 == _daos.length,\n            \"Module: invalid array lengths\"\n        );\n\n        LiquidityAction memory la = LiquidityAction(\n            _daos,\n            _tokens,\n            _pathFrom,\n            _pathTo,\n            _maxDiff,\n            _deadline,\n            0,\n            Status.ACTIVE\n        );\n        liquidityActions.push(la);\n\n        emit LiquidityActionCreated(\n            liquidityActions.length - 1,\n            _daos,\n            _tokens,\n            _pathFrom,\n            _pathTo,\n            _maxDiff,\n            _deadline\n        );\n\n        return liquidityActions.length - 1;\n    }\n\n    /**\n      * @dev                Create a new liquidity pool related action and automatically\n                            creates Deposit Contracts for each DAO that does not have one\n      * @param _daos        Array containing the DAOs that are involed in this action\n      * @param _tokens      Array containing the tokens that are involed in this action\n      * @param _pathFrom    Two-dimensional array containing the tokens flowing from the\n                            DAOs into the module:\n                              - First array level is for each token\n                              - Second array level is for each dao\n                              - Contains absolute numbers of tokens\n      * @param _pathTo      Array containing the resulting LP tokens flowing to the DAOs\n                              - Contains percentage numbers of tokens\n                              - In Basis Points (1% = 10000) \n      * @param _maxDiff     The maximum difference between the ratio resulting from the \n                            pathFrom and the actual balance of the pool (if it already \n                            exists)\n                              - In Basis Points (1% = 10000) \n      * @param _deadline    Time until which this action can be executed (unix timestamp)\n      * @return             The ID of the new action\n    */\n    function createDepositContractsAndCreateLiquidityAction(\n        address[] calldata _daos,\n        address[] calldata _tokens,\n        uint256[][] calldata _pathFrom,\n        uint256[] calldata _pathTo,\n        uint256 _maxDiff,\n        uint256 _deadline\n    ) external returns (uint256) {\n        for (uint256 i = 0; i < _daos.length; i++) {\n            if (!baseContract.hasDepositContract(_daos[i])) {\n                baseContract.createDepositContract(_daos[i]);\n            }\n        }\n\n        return\n            createLiquidityAction(\n                _daos,\n                _tokens,\n                _pathFrom,\n                _pathTo,\n                _maxDiff,\n                _deadline\n            );\n    }\n\n    /**\n     * @dev        Cancels a liquidity action\n     * @param _id  The ID of the action (position in the array)\n     */\n    function cancelLiquidityAction(uint256 _id)\n        external\n        validId(_id)\n        activeStatus(_id)\n        authorized(_id)\n    {\n        liquidityActions[_id].status = Status.CANCELLED;\n        emit LiquidityActionCancelled(_id);\n    }\n\n    /**\n      * @dev            Cancels a liquidity action\n      * @param _id      The ID of the action (position in the array)\n      * @param _amount  Amount of seconds that the current deadline will be pushed\n                        back by\n    */\n    function extendDeadline(uint256 _id, uint256 _amount)\n        external\n        validId(_id)\n        authorized(_id)\n        activeStatus(_id)\n    {\n        uint256 newDeadline = liquidityActions[_id].deadline + _amount;\n        require(\n            newDeadline > block.timestamp,\n            \"Module: new deadline is in the past\"\n        );\n\n        liquidityActions[_id].deadline = newDeadline;\n\n        emit LiquidityActionDeadlineExtended(_id, newDeadline);\n    }\n\n    /**\n      * @dev            Checks whether a liquidity action can be executed\n                        (which is the case if all DAOs have deposited)\n      * @param _id      The ID of the action (position in the array)\n      * @return         A bool flag indiciating whether the action can be executed\n    */\n    function checkExecutability(uint256 _id)\n        external\n        view\n        validId(_id)\n        returns (bool)\n    {\n        LiquidityAction memory la = liquidityActions[_id];\n        if (la.status != Status.ACTIVE) {\n            return false;\n        }\n\n        if (la.deadline < block.timestamp) {\n            return false;\n        }\n        for (uint256 i = 0; i < la.tokens.length; i++) {\n            for (uint256 j = 0; j < la.pathFrom[i].length; j++) {\n                // for each token and each pathFrom entry for this\n                // token, check whether the corresponding DAO\n                // has deposited the corresponding amount into their\n                // deposit contract\n                if (\n                    IDepositContract(\n                        baseContract.getDepositContract(la.daos[j])\n                    ).getAvailableProcessBalance(\n                            keccak256(abi.encode(moduleIdentifierString, _id)),\n                            la.tokens[i]\n                        ) < la.pathFrom[i][j]\n                ) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev            Executes a liquidity action\n     * @param _id      The ID of the action (position in the array)\n     */\n    function executeLiquidityAction(uint256 _id)\n        external\n        validId(_id)\n        activeStatus(_id)\n        authorized(_id)\n    {\n        LiquidityAction memory la = liquidityActions[_id];\n\n        require(la.deadline >= block.timestamp, \"Module: action expired\");\n\n        // Collect tokens into the module\n        uint256[] memory tokenAmountsIn = _pullTokensIntoModule(\n            _id,\n            la.daos,\n            la.tokens,\n            la.pathFrom\n        );\n\n        // Set approval for tokens\n        _approveToken(la.tokens[0], address(router), tokenAmountsIn[0]);\n        _approveToken(la.tokens[1], address(router), tokenAmountsIn[1]);\n\n        // Returns the min amounts for both tokens\n        // based on the current balance of the pool\n        // (if there are tokens already) and the\n        // maxDiff variable\n        (uint256 minA, uint256 minB) = _evaluateLPDetails(\n            la.tokens[0],\n            la.tokens[1],\n            tokenAmountsIn[0],\n            tokenAmountsIn[1],\n            la.maxDiff,\n            factory.getPair(la.tokens[0], la.tokens[1])\n        );\n\n        // Create Liquidity Position\n        (uint256 usedAmountA, uint256 usedAmountB, uint256 lpTokens) = router\n            .addLiquidity(\n                la.tokens[0],\n                la.tokens[1],\n                tokenAmountsIn[0],\n                tokenAmountsIn[1],\n                minA,\n                minB,\n                address(this),\n                la.deadline\n            );\n\n        // Store any leftover amounts\n        tokenAmountsIn[0] -= usedAmountA;\n        tokenAmountsIn[1] -= usedAmountB;\n\n        // Distribute the obtained LP tokens\n        // and return the percentage share of each DAO\n        // of the LP payouts\n        // also distributes any leftover from the original\n        // tokens according to the share of each DAO\n        _distributeTokens(\n            _id,\n            la,\n            factory.getPair(la.tokens[0], la.tokens[1]),\n            lpTokens,\n            tokenAmountsIn\n        );\n\n        la.status = Status.DONE;\n        la.executionDate = block.timestamp;\n        emit LiquidityActionExecuted(_id);\n    }\n\n    /**\n      * @dev                    Verifies whether the pool ratio resulting from the pathFrom\n                                and the actual balance of the pool (if it already exists)\n                                match based on the maxDiff value\n      * @param _tokenA          Address of the first token\n      * @param _tokenB          Address of the second token\n      * @param _amountA         Amount of the first token\n      * @param _amountB         Amount of the second token\n      * @param _maxDiff         The maximum difference between the ratio resulting from the \n                                pathFrom and the actual balance of the pool (if it already \n                                xists)\n      * @param _poolContract    The address of the new pool contract\n      * @return                 The two min values for the token amounts\n    */\n    function _evaluateLPDetails(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountA,\n        uint256 _amountB,\n        uint256 _maxDiff,\n        address _poolContract\n    ) internal view returns (uint256, uint256) {\n        uint256 balanceA = IERC20(_tokenA).balanceOf(_poolContract);\n\n        // if it's a new pool we are initializing\n        if (balanceA == 0) {\n            return (_amountA, _amountB);\n        }\n        // otherwise, get all balances\n        uint256 balanceB = IERC20(_tokenB).balanceOf(_poolContract);\n\n        // get ratio between the two values\n        // 10^36 basically addds 18 decimals to the amount to\n        // account for values below 1. This still leaves\n        // us with max values of 10^41 before we overflow\n        // which is clearly enough\n        uint256 ratio = (balanceA * 10**36) / balanceB;\n        uint256 desiredRatio = (_amountA * 10**36) / _amountB;\n\n        // ratioDiff = ((big*1000000)/small)-1000000\n        // max ratio is defined in percent is\n        // basis points, so 1% = 10000 and\n        // 100% = 1000000\n\n        if (desiredRatio >= ratio) {\n            require(\n                ((desiredRatio * 1000000) / ratio) - 1000000 <= _maxDiff,\n                \"Module: ratio difference too big\"\n            );\n        } else {\n            require(\n                ((ratio * 1000000) / desiredRatio) - 1000000 <= _maxDiff,\n                \"Module: ratio difference too big\"\n            );\n        }\n\n        // if balanceA >= balanceB\n        if (ratio >= 10**18) {\n            return (_amountA, (_amountB * ratio) / 10**18);\n        } else {\n            return ((_amountA * ratio) / 10**18, _amountB);\n        }\n    }\n\n    /**\n      * @dev                    Distributes the LP tokens as well as any leftover tokens\n                                back to the DAOs based on their LP token shares\n      * @param _id              The ID of the action (position in the array)\n      * @param _la              The LiquidityPool object containg the information\n      * @param _lpToken         Address of the lp token\n      * @param _amount          Amount of lp tokens\n      * @param _leftOverAmounts Array of leftover amounts from the input tokens\n    */\n    function _distributeTokens(\n        uint256 _id,\n        LiquidityAction memory _la,\n        address _lpToken,\n        uint256 _amount,\n        uint256[] memory _leftOverAmounts\n    ) internal {\n        uint256[] memory daoShares = new uint256[](_la.daos.length);\n        uint256 amountsTo = 0;\n        uint256 tokensLeft = _amount;\n\n        for (uint256 k = 0; k < _la.pathTo.length / 4; k++) {\n            uint256 share = 0;\n            // every 4 values, the values for a new dao start\n            // value 0 = instant amount\n            // value 1 = vested amount\n            // value 2 = vesting start\n            // value 3 = vesting end\n\n            // sending the vested amount first\n            if (_la.pathTo[k * 4 + 1] > 0) {\n                share += _la.pathTo[k * 4 + 1];\n                uint256 payout = (_amount * _la.pathTo[k * 4 + 1]) / 10000;\n                amountsTo += payout;\n                tokensLeft -= payout;\n                payout = _payFeeAndReturnRemainder(_lpToken, payout);\n                _approveDepositContract(_lpToken, _la.daos[k], payout);\n                IDepositContract(baseContract.getDepositContract(_la.daos[k]))\n                    .startVesting(\n                        _lpToken,\n                        payout, // amount\n                        _la.pathTo[k * 4 + 2], // start\n                        _la.pathTo[k * 4 + 3] // end\n                    );\n            }\n\n            // sending the instant amount\n            if (_la.pathTo[k * 4] > 0) {\n                share += _la.pathTo[k * 4];\n                uint256 payout = (_amount * _la.pathTo[k * 4]) / 10000;\n                amountsTo += payout;\n                tokensLeft -= payout;\n                // If we are at the last one, make sure that\n                // no dust is left behind\n                if (k == _la.daos.length - 1 && tokensLeft > 0) {\n                    payout += tokensLeft;\n                }\n                _transferTokenWithFee(_lpToken, _la.daos[k], payout);\n            }\n            daoShares[k] = share;\n        }\n        require(amountsTo == _amount, \"Module: amount mismatch\");\n        _distributeLeftoverTokens(_id, daoShares, _leftOverAmounts);\n    }\n\n    /**\n      * @dev                    Distributes any leftover tokens back to the DAOs based on \n                                their LP token shares\n      * @param _id              The ID of the action (position in the array)\n      * @param _daoShares       Array of the percentage shares of each DAO for LP tokens\n                                  - In Basis Points (1% = 10000) \n      * @param _amounts         Array of the amounts left for each input token\n    */\n    function _distributeLeftoverTokens(\n        uint256 _id,\n        uint256[] memory _daoShares,\n        uint256[] memory _amounts\n    ) internal {\n        require(\n            _daoShares.length == _amounts.length,\n            \"Module: array length mismatch\"\n        );\n        uint256[] memory left = _amounts;\n        for (uint256 i = 0; i < _daoShares.length; i++) {\n            for (uint256 j = 0; j < _amounts.length; j++) {\n                if (_amounts[j] > 0) {\n                    uint256 payout = (_amounts[j] * _daoShares[i]) / 10000;\n                    left[j] -= payout;\n                    // If we are at the last one, make sure that\n                    // no dust is left behind\n                    if (i == _daoShares.length - 1 && left[j] > 0) {\n                        payout += left[j];\n                    }\n                    _transferToken(\n                        liquidityActions[_id].tokens[j],\n                        liquidityActions[_id].daos[i],\n                        payout\n                    );\n                }\n            }\n        }\n    }\n\n    modifier validId(uint256 _id) {\n        require(_id <= liquidityActions.length, \"Module: id doesn't exist\");\n        _;\n    }\n\n    modifier activeStatus(uint256 _id) {\n        require(\n            liquidityActions[_id].status == Status.ACTIVE,\n            \"Module: id not active\"\n        );\n        _;\n    }\n\n    modifier authorized(uint256 _id) {\n        require(\n            baseContract.isDAOorOwnerFromArray(\n                msg.sender,\n                liquidityActions[_id].daos\n            ),\n            \"Module: not authorized\"\n        );\n        _;\n    }\n}\n"
    },
    "contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.6.2;\n\nimport \"./IUniswapV2Router01.sol\";\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n"
    },
    "contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair,\n        uint256\n    );\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(address tokenA, address tokenB)\n        external\n        returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n}\n"
    },
    "contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n}\n"
    },
    "contracts/modules/liquidity/balancer/LiquidityModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.9;\n\nimport \"../../ModuleBaseWithFee.sol\";\nimport \"../../../interfaces/IBalancerV2.sol\";\n\n/**\n * @title PrimeDeals Liquidity Module (Balancer V2)\n * @dev   Smart contract to handle liquidity pool\n *        interactions for PrimeDeals\n */\ncontract LiquidityModule_Balancer is ModuleBaseWithFee {\n    IBalancerV2 public vault;\n\n    LiquidityAction[] public liquidityActions;\n\n    struct LiquidityAction {\n        // the participating DAOs\n        address[] daos;\n        // the tokens involved in the action\n        address[] tokens;\n        // the token flow from the DAOs to the module\n        uint256[][] pathFrom;\n        // the lp token flow from the module to the DAO\n        uint256[] pathTo;\n        // the maximum difference between the\n        // token ratio from pathFrom and the\n        // actual ratio on-chain in basis points\n        // (1% = 10000)\n        uint256 maxDiff;\n        // unix timestamp of the deadline\n        uint256 deadline;\n        // unix timestamp of the execution\n        uint256 executionDate;\n        // status of the deal\n        Status status;\n    }\n\n    // pathFrom:\n    // how much tokens does each dao send to the module\n    // token -> dao -> amount\n    // [[123, 0, 123], [0, 123, 0]]\n    // token 1: dao 1 sends 123, dao 2 sends 0, dao 3 sends 123, etc.\n\n    // pathFrom:\n    // how much lp tokens does each dao receive\n    // from the module, includes vesting.\n    // since we do not know the amount of the LP tokens in any case\n    // we use percentage values here in basis points, so\n    // 100% = 1000000\n    // token -> dao -> tuple(4)\n    // [[instantAmount_dao1, vestedAmount_dao1, vestingStart_dao1,\n    // vestingEnd_dao1, instantAmount_dao2, ...], [...]]\n\n    event LiquidityActionCreated(\n        uint256 id,\n        address[] _daos,\n        address[] _tokens,\n        uint256[][] _pathFrom,\n        uint256[] _pathTo,\n        uint256 _maxDiff,\n        uint256 _deadline\n    );\n\n    event LiquidityActionCancelled(uint256 id);\n\n    event LiquidityActionDeadlineExtended(uint256 id, uint256 newDeadline);\n\n    event LiquidityActionExecuted(uint256 id);\n\n    constructor(address _baseContract, address _vault)\n        ModuleBaseWithFee(_baseContract, \"BALANCER_LIQUIDITY_MODULE\")\n    {\n        require(_vault != address(0), \"Module: invalid vault address\");\n        vault = IBalancerV2(_vault);\n    }\n\n    /**\n      * @dev                Create a new liquidity pool related action\n      * @param _daos        Array containing the DAOs that are involed in this action\n      * @param _tokens      Array containing the tokens that are involed in this action\n      * @param _pathFrom    Two-dimensional array containing the tokens flowing from the\n                            DAOs into the module:\n                              - First array level is for each token\n                              - Second array level is for each dao\n                              - Contains absolute numbers of tokens\n      * @param _pathTo      Array containing the resulting LP tokens flowing to the DAOs\n                              - Contains percentage numbers of tokens\n                              - In Basis Points (1% = 10000) \n      * @param _maxDiff     The maximum difference between the ratio resulting from the \n                            pathFrom and the actual balance of the pool (if it already \n                            exists)\n                              - In Basis Points (1% = 10000) \n      * @param _deadline    Time until which this action can be executed (unix timestamp)\n      * @return             The ID of the new action\n    */\n    function createLiquidityAction(\n        address[] calldata _daos,\n        address[] calldata _tokens,\n        uint256[][] calldata _pathFrom,\n        uint256[] calldata _pathTo,\n        uint256 _maxDiff,\n        uint256 _deadline\n    ) public returns (uint256) {\n        require(\n            baseContract.isDAOorOwnerFromArray(msg.sender, _daos),\n            \"Module: not authorized\"\n        );\n        require(_daos.length >= 2, \"Module: at least 2 daos required\");\n\n        require(\n            _tokens.length >= 2,\n            \"Module: only at least two tokens supported\"\n        );\n\n        require(_maxDiff <= 10000, \"Module: maxDiff can't be more than 100%\");\n\n        require(\n            _pathFrom.length == _pathTo.length &&\n                _pathFrom[0].length == _daos.length &&\n                _pathTo.length / 4 == _daos.length,\n            \"Module: invalid array lengths\"\n        );\n\n        LiquidityAction memory la = LiquidityAction(\n            _daos,\n            _tokens,\n            _pathFrom,\n            _pathTo,\n            _maxDiff,\n            _deadline,\n            0,\n            Status.ACTIVE\n        );\n        liquidityActions.push(la);\n        emit LiquidityActionCreated(\n            liquidityActions.length - 1,\n            _daos,\n            _tokens,\n            _pathFrom,\n            _pathTo,\n            _maxDiff,\n            _deadline\n        );\n        return liquidityActions.length - 1;\n    }\n\n    /**\n      * @dev                Create a new liquidity pool related action and automatically\n                            creates Deposit Contracts for each DAO that does not have one\n      * @param _daos        Array containing the DAOs that are involed in this action\n      * @param _tokens      Array containing the tokens that are involed in this action\n      * @param _pathFrom    Two-dimensional array containing the tokens flowing from the\n                            DAOs into the module:\n                              - First array level is for each token\n                              - Second array level is for each dao\n                              - Contains absolute numbers of tokens\n      * @param _pathTo      Array containing the resulting LP tokens flowing to the DAOs\n                              - Contains percentage numbers of tokens\n                              - In Basis Points (1% = 10000) \n      * @param _maxDiff     The maximum difference between the ratio resulting from the \n                            pathFrom and the actual balance of the pool (if it already \n                            exists)\n                              - In Basis Points (1% = 10000) \n      * @param _deadline    Time until which this action can be executed (unix timestamp)\n      * @return             The ID of the new action\n    */\n    function createDepositContractsAndCreateLiquidityAction(\n        address[] calldata _daos,\n        address[] calldata _tokens,\n        uint256[][] calldata _pathFrom,\n        uint256[] calldata _pathTo,\n        uint256 _maxDiff,\n        uint256 _deadline\n    ) external returns (uint256) {\n        for (uint256 i = 0; i < _daos.length; i++) {\n            if (!baseContract.hasDepositContract(_daos[i])) {\n                baseContract.createDepositContract(_daos[i]);\n            }\n        }\n\n        return\n            createLiquidityAction(\n                _daos,\n                _tokens,\n                _pathFrom,\n                _pathTo,\n                _maxDiff,\n                _deadline\n            );\n    }\n\n    /**\n     * @dev        Cancels a liquidity action\n     * @param _id  The ID of the action (position in the array)\n     */\n    function cancelLiquidityAction(uint256 _id)\n        external\n        validId(_id)\n        activeStatus(_id)\n        authorized(_id)\n    {\n        liquidityActions[_id].status = Status.CANCELLED;\n        emit LiquidityActionCancelled(_id);\n    }\n\n    /**\n      * @dev            Cancels a liquidity action\n      * @param _id      The ID of the action (position in the array)\n      * @param _amount  Amount of seconds that the current deadline will be pushed\n                        back by\n    */\n    function extendDeadline(uint256 _id, uint256 _amount)\n        external\n        validId(_id)\n        authorized(_id)\n        activeStatus(_id)\n    {\n        uint256 newDeadline = liquidityActions[_id].deadline + _amount;\n        require(\n            newDeadline > block.timestamp,\n            \"Module: new deadline is in the past\"\n        );\n\n        liquidityActions[_id].deadline = newDeadline;\n\n        emit LiquidityActionDeadlineExtended(_id, newDeadline);\n    }\n\n    /**\n      * @dev            Checks whether a liquidity action can be executed\n                        (which is the case if all DAOs have deposited)\n      * @param _id      The ID of the action (position in the array)\n      * @return         A bool flag indiciating whether the action can be executed\n    */\n    function checkExecutability(uint256 _id)\n        external\n        view\n        validId(_id)\n        returns (bool)\n    {\n        LiquidityAction memory la = liquidityActions[_id];\n        if (la.status != Status.ACTIVE) {\n            return false;\n        }\n\n        if (la.deadline < block.timestamp) {\n            return false;\n        }\n        for (uint256 i = 0; i < la.tokens.length; i++) {\n            for (uint256 j = 0; j < la.pathFrom[i].length; j++) {\n                if (\n                    IDepositContract(\n                        baseContract.getDepositContract(la.daos[j])\n                    ).getAvailableProcessBalance(\n                            keccak256(abi.encode(moduleIdentifierString, _id)),\n                            la.tokens[i]\n                        ) < la.pathFrom[i][j]\n                ) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev            Executes a liquidity action\n     * @param _id      The ID of the action (position in the array)\n     */\n    function executeLiquidityAction(uint256 _id)\n        external\n        validId(_id)\n        activeStatus(_id)\n        authorized(_id)\n    {\n        LiquidityAction memory la = liquidityActions[_id];\n\n        require(la.deadline >= block.timestamp, \"Module: action expired\");\n\n        // Collect tokens into the module\n        uint256[] memory tokenAmountsIn = _pullTokensIntoModule(\n            _id,\n            la.daos,\n            la.tokens,\n            la.pathFrom\n        );\n\n        // Set approval for tokens\n        _approveToken(la.tokens[0], address(vault), tokenAmountsIn[0]);\n        _approveToken(la.tokens[1], address(vault), tokenAmountsIn[1]);\n\n        IAsset[] memory assets = new IAsset[](la.tokens.length);\n        for (uint256 i = 0; i < la.tokens.length; i++) {\n            assets[i] = IAsset(la.tokens[i]);\n        }\n\n        // find pool or create pool\n        // get pool id\n        IBalancerV2.JoinPoolRequest memory joinPoolRequest = IBalancerV2\n            .JoinPoolRequest(\n                assets,\n                tokenAmountsIn,\n                abi.encode(0, tokenAmountsIn),\n                false\n            );\n\n        // IBalancerV2.joinPool(id, address(this), address(this), joinPoolRequest);\n\n        // TODO: add logic for balancer v2\n\n        la.status = Status.DONE;\n        la.executionDate = block.timestamp;\n        emit LiquidityActionExecuted(_id);\n    }\n\n    /**\n      * @dev                Distributes the LP tokens as well as any leftover tokens\n                            back to the DAOs based on their LP token shares\n      * @param _la          The LiquidityPool object containg the information\n      * @param _lpToken     Address of the lp token\n      * @param _amount      Amount of lp tokens\n      * @return _daoShares  The percentage share of each DAO for the lp tokens\n                            in basis points (1% = 10000)\n    */\n    function _distributeLPTokens(\n        LiquidityAction memory _la,\n        address _lpToken,\n        uint256 _amount\n    ) internal returns (uint256[] memory _daoShares) {\n        uint256 amountsTo = 0;\n        uint256 tokensLeft = _amount;\n        _daoShares = new uint256[](_la.daos.length);\n\n        for (uint256 k = 0; k < _la.pathTo.length / 4; k++) {\n            uint256 share = 0;\n            // every 4 values, the values for a new dao start\n            // value 0 = instant amount\n            // value 1 = vested amount\n            // value 2 = vesting start\n            // value 3 = vesting end\n\n            // sending the vested amount first\n            if (_la.pathTo[k * 4 + 1] > 0) {\n                share += _la.pathTo[k * 4 + 1];\n                uint256 payout = (_amount * _la.pathTo[k * 4 + 1]) / 10000;\n                amountsTo += payout;\n                tokensLeft -= payout;\n                payout = _payFeeAndReturnRemainder(_lpToken, payout);\n                _approveDepositContract(_lpToken, _la.daos[k], payout);\n                IDepositContract(baseContract.getDepositContract(_la.daos[k]))\n                    .startVesting(\n                        _lpToken,\n                        payout, // amount\n                        _la.pathTo[k * 4 + 2], // start\n                        _la.pathTo[k * 4 + 3] // end\n                    );\n            }\n\n            // sending the instant amount\n            if (_la.pathTo[k * 4] > 0) {\n                share += _la.pathTo[k * 4];\n                uint256 payout = (_amount * _la.pathTo[k * 4]) / 10000;\n                amountsTo += payout;\n                tokensLeft -= payout;\n                // If we are at the last one, make sure that\n                // no dust is left behind\n                if (k == _la.daos.length - 1 && tokensLeft > 0) {\n                    payout += tokensLeft;\n                }\n                _transferTokenWithFee(_lpToken, _la.daos[k], payout);\n            }\n            _daoShares[k] = share;\n        }\n        require(amountsTo == _amount, \"Module: amount mismatch\");\n    }\n\n    /**\n      * @dev                    Distributes any leftover tokens back to the DAOs based on \n                                their LP token shares\n      * @param _id              The ID of the action (position in the array)\n      * @param _daoShares       Array of the percentage shares of each DAO for LP tokens\n                                  - In Basis Points (1% = 10000) \n      * @param _amounts         Array of the amounts left for each input token\n    */\n    function _distributeLeftoverTokens(\n        uint256 _id,\n        uint256[] memory _daoShares,\n        uint256[] memory _amounts\n    ) internal {\n        require(\n            _daoShares.length == _amounts.length,\n            \"Module: array length mismatch\"\n        );\n        uint256[] memory left = _amounts;\n        for (uint256 i = 0; i < _daoShares.length; i++) {\n            for (uint256 j = 0; j < _amounts.length; j++) {\n                if (_amounts[j] > 0) {\n                    uint256 payout = (_amounts[j] * _daoShares[i]) / 10000;\n                    left[j] -= payout;\n                    // If we are at the last one, make sure that\n                    // no dust is left behind\n                    if (i == _daoShares.length - 1 && left[j] > 0) {\n                        payout += left[j];\n                    }\n                    _transferToken(\n                        liquidityActions[_id].tokens[j],\n                        liquidityActions[_id].daos[i],\n                        payout\n                    );\n                }\n            }\n        }\n    }\n\n    modifier validId(uint256 _id) {\n        require(_id <= liquidityActions.length, \"Module: id doesn't exist\");\n        _;\n    }\n\n    modifier activeStatus(uint256 _id) {\n        require(\n            liquidityActions[_id].status == Status.ACTIVE,\n            \"Module: id not active\"\n        );\n        _;\n    }\n\n    modifier authorized(uint256 _id) {\n        require(\n            baseContract.isDAOorOwnerFromArray(\n                msg.sender,\n                liquidityActions[_id].daos\n            ),\n            \"Module: not authorized\"\n        );\n        _;\n    }\n}\n"
    },
    "contracts/interfaces/IBalancerV2.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.6.2;\n\ninterface IAsset {\n    // solhint-disable-previous-line no-empty-blocks\n}\n\ninterface IBalancerV2 {\n    function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external payable;\n\n    struct JoinPoolRequest {\n        IAsset[] assets;\n        uint256[] maxAmountsIn;\n        bytes userData;\n        bool fromInternalBalance;\n    }\n}\n"
    },
    "contracts/modules/jointventure/JointVenture.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/IGnosisSafe.sol\";\nimport \"../../interfaces/IBaseContract.sol\";\nimport \"../../interfaces/IWETH.sol\";\nimport \"../ModuleBase.sol\";\n\n/**\n * @title PrimeDeals Joint Venture Module\n * @dev   Smart contract to handle joint venture\n *        interactions for PrimeDeals\n */\ncontract JointVentureModule is ModuleBase {\n    address public proxyFactory;\n    address public masterCopy;\n\n    JointVenture[] public jointVentures;\n\n    struct JointVenture {\n        // the participating DAOs\n        address[] daos;\n        // the members of the new safe\n        address[] safeMembers;\n        // the voting threshold of the\n        // new safe\n        uint256 safeThreshold;\n        // the tokens involved in the action\n        address[] tokens;\n        // the token flow from the DAOs to the module\n        uint256[][] pathFrom;\n        // unix timestamp of the deadline\n        uint256 deadline;\n        // unix timestamp of the execution\n        uint256 executionDate;\n        // status of the deal\n        Status status;\n    }\n\n    // pathFrom:\n    // how much tokens does each dao send to the module\n    // token -> dao -> amount\n    // [[123, 0, 123], [0, 123, 0]]\n    // token 1: dao 1 sends 123, dao 2 sends 0, dao 3 sends 123, etc.\n\n    event JointVentureActionCreated(\n        uint256 id,\n        address[] _daos,\n        address[] _safeMembers,\n        uint256 _safeThreshold,\n        address[] _tokens,\n        uint256[][] _pathFrom,\n        uint256 _deadline\n    );\n\n    event JointVentureActionCancelled(uint256 id);\n\n    event JointVentureActionExecuted(uint256 id);\n\n    constructor(\n        address _baseContract,\n        address _proxyFactory,\n        address _masterCopy\n    ) ModuleBase(_baseContract, \"JOINT_VENTURE_MODULE\") {\n        require(\n            _proxyFactory != address(0),\n            \"Module: invalid proxy factory address\"\n        );\n        proxyFactory = _proxyFactory;\n        require(\n            _masterCopy != address(0),\n            \"Module: invalid master copy address\"\n        );\n        masterCopy = _masterCopy;\n    }\n\n    /**\n      * @dev                    Create a new joint venture action\n      * @param _daos            Array containing the DAOs that are involed in this action\n      * @param _safeMembers     Array containing the new safe members\n      * @param _safeThreshold   Voting threshold of the new safe\n      * @param _tokens          Array containing the tokens that are involed in this action\n      * @param _pathFrom        Two-dimensional array containing the tokens flowing from the\n                                DAOs into the module:\n                                  - First array level is for each token\n                                  - Second array level is for each dao\n                                  - Contains absolute numbers of tokens\n     \n      * @param _deadline        Time until which this action can be executed (unix timestamp)\n      * @return                 The ID of the new action\n    */\n    function createJointVentureAction(\n        address[] calldata _daos,\n        address[] calldata _safeMembers,\n        uint256 _safeThreshold,\n        address[] calldata _tokens,\n        uint256[][] calldata _pathFrom,\n        uint256 _deadline\n    ) public returns (uint256) {\n        require(\n            baseContract.isDAOorOwnerFromArray(msg.sender, _daos),\n            \"Module: not authorized\"\n        );\n        require(_daos.length >= 2, \"Module: at least 2 daos required\");\n\n        require(\n            _safeMembers.length >= 1 && _tokens.length >= 1,\n            \"Module: invalid inputs\"\n        );\n\n        require(\n            _safeThreshold >= 1 && _safeThreshold <= _safeMembers.length,\n            \"Module: invalid safe threshold\"\n        );\n\n        uint256 id = jointVentures.length + 1;\n        JointVenture memory jv = JointVenture(\n            _daos,\n            _safeMembers,\n            _safeThreshold,\n            _tokens,\n            _pathFrom,\n            _deadline,\n            0,\n            Status.ACTIVE\n        );\n        jointVentures.push(jv);\n\n        emit JointVentureActionCreated(\n            id,\n            _daos,\n            _safeMembers,\n            _safeThreshold,\n            _tokens,\n            _pathFrom,\n            _deadline\n        );\n\n        return id;\n    }\n\n    /**\n      * @dev                    Create a new joint venture action and automatically\n                                creates Deposit Contracts for each DAO that does not have one\n      * @param _daos            Array containing the DAOs that are involed in this action\n      * @param _safeMembers     Array containing the new safe members\n      * @param _safeThreshold   Voting threshold of the new safe\n      * @param _tokens          Array containing the tokens that are involed in this action\n      * @param _pathFrom        Two-dimensional array containing the tokens flowing from the\n                                DAOs into the module:\n                                  - First array level is for each token\n                                  - Second array level is for each dao\n                                  - Contains absolute numbers of tokens\n     \n      * @param _deadline        Time until which this action can be executed (unix timestamp)\n      * @return                 The ID of the new action\n    */\n    function createDepositContractsAndCreateJointVentureAction(\n        address[] calldata _daos,\n        address[] calldata _safeMembers,\n        uint256 _safeThreshold,\n        address[] calldata _tokens,\n        uint256[][] calldata _pathFrom,\n        uint256 _deadline\n    ) external returns (uint256) {\n        for (uint256 i = 0; i < _daos.length; i++) {\n            if (!baseContract.hasDepositContract(_daos[i])) {\n                baseContract.createDepositContract(_daos[i]);\n            }\n        }\n        return\n            createJointVentureAction(\n                _daos,\n                _safeMembers,\n                _safeThreshold,\n                _tokens,\n                _pathFrom,\n                _deadline\n            );\n    }\n\n    /**\n     * @dev        Cancels a joint venture action\n     * @param _id  The ID of the action (position in the array)\n     */\n    function cancelJointVentureAction(uint256 _id)\n        external\n        validId(_id)\n        activeStatus(_id)\n        authorized(_id)\n    {\n        jointVentures[_id].status = Status.CANCELLED;\n        emit JointVentureActionCancelled(_id);\n    }\n\n    /**\n      * @dev            Checks whether a joint venture action can be executed\n                        (which is the case if all DAOs have deposited)\n      * @param _id      The ID of the action (position in the array)\n      * @return         A bool flag indiciating whether the action can be executed\n    */\n    function checkExecutability(uint256 _id)\n        external\n        view\n        validId(_id)\n        returns (bool)\n    {\n        JointVenture storage jv = jointVentures[_id];\n\n        if (jv.status != Status.ACTIVE) {\n            return false;\n        }\n\n        if (jv.deadline < block.timestamp) {\n            return false;\n        }\n        for (uint256 i = 0; i < jv.tokens.length; i++) {\n            for (uint256 j = 0; j < jv.pathFrom[i].length; j++) {\n                // for each token and each pathFrom entry for this\n                // token, check whether the corresponding DAO\n                // has deposited the corresponding amount into their\n                // deposit contract\n                if (\n                    IDepositContract(\n                        baseContract.getDepositContract(jv.daos[j])\n                    ).getAvailableProcessBalance(\n                            keccak256(abi.encode(moduleIdentifierString, _id)),\n                            jv.tokens[i]\n                        ) < jv.pathFrom[i][j]\n                ) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev            Executes a joint venture action\n     * @param _id      The ID of the action (position in the array)\n     */\n    function executeJointVentureAction(uint256 _id)\n        external\n        validId(_id)\n        authorized(_id)\n        activeStatus(_id)\n    {\n        JointVenture memory jv = jointVentures[_id];\n\n        require(jv.deadline >= block.timestamp, \"Module: action expired\");\n\n        // collect tokens into the module\n        uint256[] memory tokenAmountsIn = _pullTokensIntoModule(\n            _id,\n            jv.daos,\n            jv.tokens,\n            jv.pathFrom\n        );\n\n        // deploy the new gnosis safe with the parameters\n        address payable safe = _deploySafe(jv.safeMembers, jv.safeThreshold);\n\n        // send the collected funds to thew new safe\n        _sendFundsToSafe(safe, jv.tokens, tokenAmountsIn);\n\n        jv.status = Status.DONE;\n        jv.executionDate = block.timestamp;\n        emit JointVentureActionExecuted(_id);\n    }\n\n    /**\n     * @dev                     Deploys the Gnosis Safe\n     * @param _safeMembers      Array of the addresses owning the new safe\n     * @param _safeThreshold    Voting Threshold of the new safe\n     * @return                  The address of the newly deployed safe\n     */\n    function _deploySafe(address[] memory _safeMembers, uint256 _safeThreshold)\n        internal\n        returns (address payable)\n    {\n        bytes memory safeInitData = abi.encodeWithSelector(\n            GnosisSafeSetup.setup.selector,\n            _safeMembers, // safe owners\n            _safeThreshold, // threshold\n            address(0x0), // to (for callback)\n            new bytes(0), // data (for callback)\n            address(0x0), // handler (for callback)\n            address(0x0), // payment token (for gasless creation)\n            0, // payment amount (for gasless creation)\n            address(0x0) // payment receiver (for gasless creation)\n        );\n\n        address payable safe = ProxyFactory(proxyFactory).createProxy(\n            masterCopy,\n            safeInitData\n        );\n\n        require(safe != address(0x0), \"Module: safe deployment failed\");\n        return safe;\n    }\n\n    /**\n     * @dev             Sends the collected funds to the new safe\n     * @param _safe     Address of the new safe\n     * @param _tokens   Array of token addresses\n     * @param _amounts  Array of amounts for each token to be sent\n     */\n    function _sendFundsToSafe(\n        address payable _safe,\n        address[] memory _tokens,\n        uint256[] memory _amounts\n    ) internal {\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            if (_tokens[i] != baseContract.weth()) {\n                _transferToken(_tokens[i], _safe, _amounts[i]);\n            } else {\n                IWETH(baseContract.weth()).withdraw(_amounts[i]);\n                (bool sent, ) = _safe.call{value: _amounts[i]}(\"\");\n                require(sent, \"Module: failed to send ether to new safe\");\n            }\n        }\n    }\n\n    modifier validId(uint256 _id) {\n        require(_id <= jointVentures.length, \"Module: id doesn't exist\");\n        _;\n    }\n\n    modifier activeStatus(uint256 _id) {\n        require(\n            jointVentures[_id].status == Status.ACTIVE,\n            \"Module: id not active\"\n        );\n        _;\n    }\n\n    modifier authorized(uint256 _id) {\n        require(\n            baseContract.isDAOorOwnerFromArray(\n                msg.sender,\n                jointVentures[_id].daos\n            ),\n            \"Module: not authorized\"\n        );\n        _;\n    }\n}\n"
    },
    "contracts/interfaces/IGnosisSafe.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.6.2;\n\ninterface GnosisSafeSetup {\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    ) external;\n}\n\ninterface ProxyFactory {\n    function createProxy(address masterCopy, bytes calldata data)\n        external\n        returns (address payable proxy);\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.5.0;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/DepositContract.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IBaseContract.sol\";\nimport \"./interfaces/IWETH.sol\";\n\ncontract DepositContract {\n    address public dao;\n    IBaseContract public baseContract;\n\n    mapping(address => uint256) public tokenBalances;\n    mapping(address => mapping(bytes32 => uint256))\n        public availableModuleBalances;\n    mapping(address => uint256) public vestedBalances;\n\n    // Contains the module descriptor and the ID of the swap/action\n    // so we can identify deposits for each individual interaction\n    // e.g. keccak256(abi.encode(\"TOKEN_SWAP_MODULE\", 42));\n    // for a deposit for a token swap with the id 42\n    mapping(bytes32 => Deposit[]) public deposits;\n\n    Vesting[] public vestings;\n\n    struct Deposit {\n        address sender;\n        address token;\n        uint256 amount;\n        uint256 used;\n        uint256 time;\n    }\n\n    struct Vesting {\n        address token;\n        uint256 amount;\n        uint256 sent;\n        uint256 start;\n        uint256 end;\n    }\n\n    event Deposited(\n        bytes32 processID,\n        uint256 depositID,\n        address token,\n        uint256 amount,\n        address sender\n    );\n\n    event Withdrawn(\n        bytes32 processID,\n        uint256 depositID,\n        address to,\n        address token,\n        uint256 amount\n    );\n\n    event VestingStarted(\n        bytes32 processID,\n        address token,\n        uint256 amount,\n        uint256 vestingStart,\n        uint256 vestingEnd\n    );\n\n    function initialize(address _dao) external {\n        require(dao == address(0), \"D2D-DEPOSIT-ALREADY-INITIALIZED\");\n        require(_dao != address(0), \"D2D-DEPOSIT-INVALID-DAO-ADDRESS\");\n        dao = _dao;\n        baseContract = IBaseContract(msg.sender);\n    }\n\n    function migrateBaseContract(address _newBaseContract)\n        external\n        onlyBaseContract\n    {\n        baseContract = IBaseContract(_newBaseContract);\n    }\n\n    function deposit(\n        bytes32 _processID,\n        address _token,\n        uint256 _amount\n    ) public payable {\n        require(\n            (_token != address(0) && _amount > 0) ||\n                (_token == address(0) && msg.value > 0),\n            \"D2D-DEPOSIT-INVALID-TOKEN-AMOUNT\"\n        );\n        if (_token != address(0)) {\n            _transferTokenFrom(_token, msg.sender, address(this), _amount);\n        } else {\n            _amount = msg.value;\n            _token = baseContract.weth();\n            IWETH(_token).deposit{value: _amount}();\n        }\n\n        tokenBalances[_token] += _amount;\n        availableModuleBalances[_token][_processID] += _amount;\n        verifyBalance(_token);\n        // solhint-disable-next-line not-rely-on-time\n        deposits[_processID].push(\n            Deposit(msg.sender, _token, _amount, 0, block.timestamp)\n        );\n\n        emit Deposited(\n            _processID,\n            deposits[_processID].length,\n            _token,\n            _amount,\n            msg.sender\n        );\n    }\n\n    function multipleDeposits(\n        bytes32 _processID,\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    ) external payable {\n        // solhint-disable-next-line reason-string\n        require(\n            _tokens.length == _amounts.length,\n            \"D2D-DEPOSIT-ARRAY-LENGTH-MISMATCH\"\n        );\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            deposit(_processID, _tokens[i], _amounts[i]);\n        }\n    }\n\n    function registerDeposit(bytes32 _processID, address _token)\n        public\n        onlyAuthorized\n    {\n        uint256 currentBalance = 0;\n        if (_token != address(0)) {\n            currentBalance = IERC20(_token).balanceOf(address(this));\n        } else {\n            _token = baseContract.weth();\n            currentBalance = address(this).balance;\n        }\n        if (currentBalance > tokenBalances[_token]) {\n            uint256 amount = currentBalance - tokenBalances[_token];\n            tokenBalances[_token] = currentBalance;\n            if (_token == address(0)) {\n                IWETH(_token).deposit{value: amount}();\n            }\n            availableModuleBalances[_token][_processID] += amount;\n            deposits[_processID].push(\n                Deposit(dao, _token, amount, 0, block.timestamp)\n            );\n            emit Deposited(\n                _processID,\n                deposits[_processID].length,\n                _token,\n                amount,\n                dao\n            );\n        }\n        verifyBalance(_token);\n    }\n\n    function registerDeposits(bytes32 _processID, address[] calldata _tokens)\n        external\n    {\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            registerDeposit(_processID, _tokens[i]);\n        }\n    }\n\n    function withdraw(bytes32 _processID, uint256 _depositID)\n        external\n        returns (\n            address,\n            address,\n            uint256\n        )\n    {\n        require(\n            deposits[_processID].length >= _depositID,\n            \"D2D-DEPOSIT-INVALID-DEPOSIT-ID\"\n        );\n        Deposit storage d = deposits[_processID][_depositID];\n        // Either the caller did the deposit or it's a dao deposit\n        // and the caller is the dao or a representative\n        require(\n            d.sender == msg.sender ||\n                (d.sender == dao && baseContract.isDAOorOwner(msg.sender, dao)),\n            \"D2D-WITHDRAW-NOT-AUTHORIZED\"\n        );\n\n        uint256 freeAmount = d.amount - d.used;\n        // Deposit can't be used by a module or withdrawn already\n        require(freeAmount > 0, \"D2D-DEPOSIT-NOT-WITHDRAWABLE\");\n        d.used = d.amount;\n        availableModuleBalances[d.token][_processID] -= freeAmount;\n        tokenBalances[d.token] -= freeAmount;\n\n        // If it's a token\n        if (d.token != baseContract.weth()) {\n            _transferToken(d.token, d.sender, freeAmount);\n            // Else if it's Ether\n        } else {\n            IWETH(baseContract.weth()).withdraw(freeAmount);\n            require(\n                address(this).balance >= freeAmount,\n                \"D2D-DEPOSIT-INVALID-AMOUNT\"\n            );\n            (bool sent, ) = d.sender.call{value: freeAmount}(\"\");\n            require(sent, \"D2D-DEPOSIT-FAILED-TO-SEND-ETHER\");\n        }\n\n        emit Withdrawn(_processID, _depositID, d.sender, d.token, freeAmount);\n        return (d.sender, d.token, freeAmount);\n    }\n\n    function sendToModule(\n        bytes32 _processID,\n        address _token,\n        uint256 _amount\n    ) external onlyModule returns (bool) {\n        uint256 amountLeft = _amount;\n        for (uint256 i = 0; i < deposits[_processID].length; i++) {\n            if (deposits[_processID][i].token == _token) {\n                uint256 freeAmount = deposits[_processID][i].amount -\n                    deposits[_processID][i].used;\n                if (freeAmount > amountLeft) {\n                    freeAmount = amountLeft;\n                }\n                amountLeft -= freeAmount;\n                deposits[_processID][i].used += freeAmount;\n                if (amountLeft == 0) {\n                    if (_token == address(0)) {\n                        IWETH(baseContract.weth()).withdraw(_amount);\n                        (bool sent, ) = msg.sender.call{value: _amount}(\"\");\n                        require(sent, \"D2D-DEPOSIT-FAILED-TO-SEND-ETHER\");\n                    } else {\n                        _transferToken(_token, msg.sender, _amount);\n                        tokenBalances[_token] -= _amount;\n                    }\n                    availableModuleBalances[_token][_processID] -= _amount;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    function startVesting(\n        address _token,\n        uint256 _amount,\n        uint256 _start,\n        uint256 _end\n    ) external onlyModule {\n        // solhint-disable-next-line reason-string\n        require(\n            _token != address(0),\n            \"D2D-DEPOSIT-VESTING-INVALID-TOKEN-ADDRESS\"\n        );\n        // solhint-disable-next-line reason-string\n        require(_amount > 0, \"D2D-DEPOSIT-VESTING-INVALID-AMOUNT\");\n        // solhint-disable-next-line reason-string\n        require(\n            _start < _end,\n            \"D2D-DEPOSIT-VESTING-INVALID-START-AND-END-TIMES\"\n        );\n\n        _transferTokenFrom(_token, msg.sender, address(this), _amount);\n        vestedBalances[_token] += _amount;\n        vestings.push(Vesting(_token, _amount, 0, _start, _end));\n    }\n\n    function claimVestings() external onlyAuthorized {\n        for (uint256 i = 0; i < vestings.length; i++) {\n            if (vestings[i].sent < vestings[i].amount) {\n                if (block.timestamp < vestings[i].start) {\n                    break;\n                }\n                uint256 amount = 0;\n                if (block.timestamp >= vestings[i].end) {\n                    amount = vestings[i].amount - vestings[i].sent;\n                    vestings[i].sent = vestings[i].amount;\n                } else {\n                    uint256 fullDuration = vestings[i].end - vestings[i].start;\n                    uint256 elapsed = vestings[i].end - block.timestamp;\n                    amount = (vestings[i].amount * fullDuration) / elapsed;\n                    vestings[i].sent += amount;\n                }\n                // solhint-disable-next-line reason-string\n                require(\n                    vestings[i].sent <= vestings[i].amount,\n                    \"D2D-VESTING-CLAIM-AMOUNT-MISMATCH\"\n                );\n                vestedBalances[vestings[i].token] -= amount;\n                if (vestings[i].token != baseContract.weth()) {\n                    _transferToken(vestings[i].token, dao, amount);\n                } else {\n                    IWETH(baseContract.weth()).withdraw(amount);\n                    (bool sent, ) = dao.call{value: amount}(\"\");\n                    require(sent, \"D2D-DEPOSIT-FAILED-TO-SEND-ETHER\");\n                }\n            }\n        }\n    }\n\n    function verifyBalance(address _token) public view {\n        if (_token == address(0)) {\n            _token = baseContract.weth();\n        }\n\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n        require(\n            balance >= tokenBalances[_token] + vestedBalances[_token],\n            \"D2D-DEPOSIT-BALANCE-INVALID\"\n        );\n    }\n\n    function getDeposit(bytes32 _processID, uint256 _depositID)\n        public\n        view\n        returns (\n            address,\n            address,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        Deposit memory d = deposits[_processID][_depositID];\n        return (\n            d.sender,\n            d.token == baseContract.weth() ? address(0) : d.token,\n            d.amount,\n            d.used,\n            d.time\n        );\n    }\n\n    function getDepositRange(\n        bytes32 _processID,\n        uint256 _fromDepositID,\n        uint256 _toDepositID\n    )\n        external\n        view\n        returns (\n            address[] memory senders,\n            address[] memory tokens,\n            uint256[] memory amounts,\n            uint256[] memory usedAmounts,\n            uint256[] memory times\n        )\n    {\n        uint256 range = 2 + _toDepositID - _fromDepositID; // inclusive range\n        senders = new address[](range);\n        tokens = new address[](range);\n        amounts = new uint256[](range);\n        usedAmounts = new uint256[](range);\n        times = new uint256[](range);\n        for (uint256 i = _toDepositID; i <= _fromDepositID; i++) {\n            (\n                senders[i],\n                tokens[i],\n                amounts[i],\n                usedAmounts[i],\n                times[i]\n            ) = getDeposit(_processID, i);\n        }\n        return (senders, tokens, amounts, usedAmounts, times);\n    }\n\n    function getAvailableProcessBalance(bytes32 _processID, address _token)\n        external\n        view\n        returns (uint256)\n    {\n        return availableModuleBalances[_token][_processID];\n    }\n\n    function getTotalDepositCount(bytes32 _processID)\n        external\n        view\n        returns (uint256)\n    {\n        return deposits[_processID].length;\n    }\n\n    function getWithdrawableAmountOfUser(\n        bytes32 _processID,\n        address _user,\n        address _token\n    ) external view returns (uint256) {\n        uint256 freeAmount = 0;\n        for (uint256 i = 0; i < deposits[_processID].length; i++) {\n            if (\n                deposits[_processID][i].sender == _user &&\n                deposits[_processID][i].token == _token\n            ) {\n                freeAmount += (deposits[_processID][i].amount -\n                    deposits[_processID][i].used);\n            }\n        }\n        return freeAmount;\n    }\n\n    function getBalance(address _token) external view returns (uint256) {\n        if (_token == address(0)) {\n            return address(this).balance;\n        }\n        return tokenBalances[_token];\n    }\n\n    function getVestedBalance(address _token) external view returns (uint256) {\n        return vestedBalances[_token];\n    }\n\n    function getProcessID(string memory _module, uint256 _id)\n        external\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(_module, _id));\n    }\n\n    function _transferToken(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) internal {\n        require(\n            IERC20(_token).transfer(_to, _amount),\n            \"D2D-TOKEN-TRANSFER-FAILED\"\n        );\n    }\n\n    function _transferTokenFrom(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        require(\n            IERC20(_token).transferFrom(_from, _to, _amount),\n            \"D2D-TOKEN-TRANSFER-FAILED\"\n        );\n    }\n\n    modifier onlyBaseContract() {\n        // solhint-disable-next-line reason-string\n        require(\n            msg.sender == address(baseContract),\n            \"D2D-DEPOSIT-ONLY-BASE-CONTRACT-CAN-ACCESS\"\n        );\n        _;\n    }\n\n    modifier onlyAuthorized() {\n        require(\n            baseContract.isDAOorOwner(msg.sender, dao),\n            \"D2D-NOT-AUTHORIZED\"\n        );\n        _;\n    }\n\n    modifier onlyModule() {\n        require(baseContract.addressIsModule(msg.sender), \"D2D-NOT-MODULE\");\n        _;\n    }\n}\n"
    },
    "contracts/modules/Blueprint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.9;\n\nimport \"./ModuleBase.sol\";\nimport \"../interfaces/IBaseContract.sol\";\n\ncontract BlueprintModule is ModuleBase {\n    Blueprint[] public blueprints;\n\n    struct Blueprint {\n        address[] daos;\n        uint256 value1;\n        address value2;\n        string value3;\n        uint256 executionDate;\n        Status status;\n    }\n\n    event ActionCreated(\n        uint256 id,\n        address[] _daos,\n        uint256 value1,\n        address value2,\n        string value3\n    );\n\n    event ActionCancelled(uint256 id);\n\n    event ActionExecuted(uint256 id);\n\n    constructor(address _baseContract)\n        ModuleBase(_baseContract, \"BLUEPRINT_MODULE\")\n    {}\n\n    function createAction(\n        address[] calldata _daos,\n        uint256 _value1,\n        address _value2,\n        string calldata _value3\n    ) public returns (uint256) {\n        require(\n            baseContract.isDAOorOwnerFromArray(msg.sender, _daos),\n            \"Module: not authorized\"\n        );\n        require(_daos.length >= 2, \"Module: at least 2 daos required\");\n\n        require(\n            _value1 > 0 && _value2 != address(0) && bytes(_value3).length > 0,\n            \"Module: invalid inputs\"\n        );\n\n        uint256 id = blueprints.length + 1;\n        Blueprint memory newBlueprint = Blueprint(\n            _daos,\n            _value1,\n            _value2,\n            _value3,\n            0,\n            Status.ACTIVE\n        );\n        blueprints.push(newBlueprint);\n        emit ActionCreated(id, _daos, _value1, _value2, _value3);\n        return id;\n    }\n\n    function createDepositContractsAndCreateAction(\n        address[] calldata _daos,\n        uint256 _value1,\n        address _value2,\n        string calldata _value3\n    ) external returns (uint256) {\n        uint256 newId = createAction(_daos, _value1, _value2, _value3);\n        for (uint256 i = 0; i < _daos.length; i++) {\n            if (!baseContract.hasDepositContract(_daos[i])) {\n                baseContract.createDepositContract(_daos[i]);\n            }\n        }\n        return newId;\n    }\n\n    function cancelAction(uint256 _id)\n        external\n        validId(_id)\n        activeStatus(_id)\n        authorized(_id)\n    {\n        blueprints[_id].status = Status.CANCELLED;\n        emit ActionCancelled(_id);\n    }\n\n    function checkExecutability(uint256 _id)\n        external\n        view\n        validId(_id)\n        returns (bool)\n    {\n        Blueprint storage blueprint = blueprints[_id];\n        if (blueprint.status != Status.ACTIVE) {\n            return false;\n        }\n\n        if (\n            blueprint.value1 > 0 &&\n            blueprint.value2 != address(0) &&\n            bytes(blueprint.value3).length > 0\n        ) {\n            return true;\n        }\n\n        return true;\n    }\n\n    function executeAction(uint256 _id)\n        external\n        validId(_id)\n        authorized(_id)\n        activeStatus(_id)\n    {\n        Blueprint memory blueprint = blueprints[_id];\n\n        require(\n            blueprint.value1 > 0 &&\n                blueprint.value2 != address(0) &&\n                bytes(blueprint.value3).length > 0,\n            \"Module: execution conditions not met\"\n        );\n\n        blueprint.status = Status.DONE;\n        blueprint.executionDate = block.timestamp;\n        emit ActionExecuted(_id);\n    }\n\n    modifier validId(uint256 _id) {\n        require(_id <= blueprints.length, \"Module: id doesn't exist\");\n        _;\n    }\n\n    modifier activeStatus(uint256 _id) {\n        require(\n            blueprints[_id].status == Status.ACTIVE,\n            \"Module: id not active\"\n        );\n        _;\n    }\n\n    modifier authorized(uint256 _id) {\n        require(\n            baseContract.isDAOorOwnerFromArray(\n                msg.sender,\n                blueprints[_id].daos\n            ),\n            \"Module: not authorized\"\n        );\n        _;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "contracts/tests/TestToken.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract TestToken is ERC20 {\n    uint256 public constant MAX_SUPPLY = 1000000000 * 10**18; // 1 billion\n\n    constructor() ERC20(\"Test Token\", \"TT\") {\n        require(totalSupply() == 0, \"XGT-ALREADY-INITIALIZED\");\n        _mint(msg.sender, MAX_SUPPLY);\n        require(totalSupply() == MAX_SUPPLY, \"XGT-INVALID-SUPPLY\");\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}