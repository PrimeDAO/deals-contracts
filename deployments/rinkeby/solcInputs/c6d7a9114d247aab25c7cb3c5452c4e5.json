{
  "language": "Solidity",
  "sources": {
    "contracts/DaoDepositManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IDealManager.sol\";\nimport \"./interfaces/IModuleBase.sol\";\n\n/**\n * @title                   PrimeDeals Dao Deposit Manager\n * @notice                  Smart contract to manage the\n                            deposits, withdraws and vestings of a DAO\n */\ncontract DaoDepositManager {\n    /// DAO address to which this DaoDepositContract is linked\n    address public dao;\n    /// Address of the DealManager implementation\n    IDealManager public dealManager;\n    /// token address => balance\n    mapping(address => uint256) public tokenBalances;\n    /// token address => deal module address => deal module id => balance\n    mapping(address => mapping(address => mapping(uint32 => uint256)))\n        public availableDealBalances;\n    /// token address => balance\n    mapping(address => uint256) public vestedBalances;\n    /// deal module address => deal id => deposits array\n    mapping(address => mapping(uint256 => Deposit[])) public deposits;\n    /// Array of vestings where the index is the vesting ID\n    Vesting[] public vestings;\n    /// Array of all the token addresses that are vested\n    address[] public vestedTokenAddresses;\n    /// token address => amount\n    mapping(address => uint256) public vestedTokenAmounts;\n    /// deal module address => deal id => token counter\n    mapping(address => mapping(uint256 => uint256)) public tokensPerDeal;\n\n    struct Deposit {\n        /// The depositor of the tokens\n        address depositor;\n        /// The address of the ERC20 token or ETH (ZERO address), that is deposited\n        address token;\n        /// Amount of the token being deposited\n        uint256 amount;\n        /// The amount already used for a Deal\n        uint256 used;\n        /// Unix timestamp of the deposit\n        uint32 depositedAt;\n    }\n\n    struct Vesting {\n        /// The address of the module to which this vesting is linked\n        address dealModule;\n        /// The ID for a specific deal, that is stored in the module\n        uint32 dealId;\n        /// The address of the ERC20 token or ETH (ZERO address)\n        address token;\n        /// The total amount being vested\n        uint256 totalVested;\n        /// The total amount of claimed vesting\n        uint256 totalClaimed;\n        /// The Unix timestamp when the vesting has been initiated\n        uint32 startTime;\n        /// The duration after which tokens can be claimed starting from the vesting start,\n        /// in seconds\n        uint32 cliff;\n        /// The duration the tokens are vested, in seconds\n        uint32 duration;\n    }\n\n    /**\n     * @notice                  This event is emitted when a deposit is made\n     * @param dealModule        The module address of which the dealId is part off\n     * @param dealId            A specific deal, that is part of the dealModule, for which a\n                                deposit is made\n     * @param depositor         The address of the depositor\n     * @param depositId         The ID of the deposit action (position in array)\n     * @param token             The address of the ERC20 token or ETH (ZERO address)deposited\n     * @param amount            The amount that is deposited\n     */\n    event Deposited(\n        address indexed dealModule,\n        uint32 indexed dealId,\n        address indexed depositor,\n        uint32 depositId,\n        address token,\n        uint256 amount\n    );\n\n    /**\n     * @notice                  This event is emitted when a withdraw is made\n     * @param dealModule        The module address of which the dealId is part off\n     * @param dealId            A specific deal, that is part of the dealModule, for which a\n                                withdraw is made\n     * @param depositor         The address of the depositor of the funds that are withdrawn\n     * @param depositId         The ID of the deposit action (position in array)\n     * @param token             The address of the ERC20 token or ETH (ZERO address) withdrawn\n     * @param amount            The amount that is withdrawn\n     */\n    event Withdrawn(\n        address indexed dealModule,\n        uint32 indexed dealId,\n        address indexed depositor,\n        uint32 depositId,\n        address token,\n        uint256 amount\n    );\n\n    /**\n     * @notice                  This event is emitted when a vesting is started\n     * @param dealModule        The module address of which the dealId is part off\n     * @param dealId            A specific deal, that is part of the dealModule, for which a\n                                vesting is started\n     * @param vestingStart      The Unix timestamp of when the vesting has been initiated\n     * @param vestingCliff      The vesting cliff, after which tokens can be claimed\n     * @param vestingDuration   The duration the tokens are vested, in seconds\n     * @param token             The address of the ERC20 token or ETH (ZERO address)\n     * @param amount            The amount that is being vested\n     */\n    event VestingStarted(\n        address indexed dealModule,\n        uint32 indexed dealId,\n        uint256 indexed vestingStart,\n        uint32 vestingCliff,\n        uint32 vestingDuration,\n        address token,\n        uint256 amount\n    );\n\n    /**\n     * @notice              This event is emitted when a vesting is claimed\n     * @param dealModule    The module address of which the dealId is part off\n     * @param dealId        A specific deal, that is part of the dealModule, for which a\n                            vesting is claimed\n     * @param dao           The address of the DAO, to which the claimed vesting is sent\n     * @param token         The address of the ERC20 token or ETH (ZERO address)\n     * @param claimed       The amount that is being claimed\n     */\n    event VestingClaimed(\n        address indexed dealModule,\n        uint32 indexed dealId,\n        address indexed dao,\n        address token,\n        uint256 claimed\n    );\n\n    /**\n     * @notice              Initialize the DaoDepositManager\n     * @param _dao          The DAO address to which this contract belongs\n     */\n    function initialize(address _dao) external {\n        require(dao == address(0), \"DaoDepositManager: Error 001\");\n        require(\n            _dao != address(0) && _dao != address(this),\n            \"DaoDepositManager: Error 100\"\n        );\n        dao = _dao;\n        dealManager = IDealManager(msg.sender);\n    }\n\n    /**\n     * @notice                      Sets a new address for the DealManager implementation\n     * @param _newDaoDepositManager The address of the new DealManager\n     */\n    function setDealManagerImplementation(address _newDaoDepositManager)\n        external\n        onlyDealManager\n    {\n        require(\n            _newDaoDepositManager != address(0) &&\n                _newDaoDepositManager != address(this),\n            \"DaoDepositManager: Error 100\"\n        );\n        dealManager = IDealManager(_newDaoDepositManager);\n    }\n\n    /**\n     * @notice              Transfers the token amount to the DaoDepositManager and stores\n                            the parameters in a Deposit structure.\n     * @dev                 Note: if ETH is deposited, the token address should be ZERO (0)\n     * @param _module       The address of the module for which is being deposited\n     * @param _dealId       The dealId to which this deposit is part of\n     * @param _token        The address of the ERC20 token or ETH (ZERO address)\n     * @param _amount       The amount that is deposited\n     */\n    function deposit(\n        address _module,\n        uint32 _dealId,\n        address _token,\n        uint256 _amount\n    ) public payable {\n        require(_amount > 0, \"DaoDepositManager: Error 101\");\n        if (_token != address(0)) {\n            _transferFrom(_token, msg.sender, address(this), _amount);\n        } else {\n            require(_amount == msg.value, \"DaoDepositManager: 202\");\n        }\n\n        tokenBalances[_token] += _amount;\n        availableDealBalances[_token][_module][_dealId] += _amount;\n        verifyBalance(_token);\n        deposits[_module][_dealId].push(\n            // solhint-disable-next-line not-rely-on-time\n            Deposit(msg.sender, _token, _amount, 0, uint32(block.timestamp))\n        );\n\n        emit Deposited(\n            _module,\n            _dealId,\n            msg.sender,\n            uint32(deposits[_module][_dealId].length - 1),\n            _token,\n            _amount\n        );\n    }\n\n    /**\n     * @notice              Transfers multiple tokens and amounts to the DaoDepositManager and\n                            stores the parameters for each deposit in a Deposit structure.\n     * @dev                 Note: if ETH is deposited, the token address should be ZERO (0)\n                            Note: when calling this function, it is only possible to have 1 ETH\n                            deposit, meaning only 1  of the token addresses can be a ZERO address     \n     * @param _module       The address of the module for which is being deposited\n     * @param _dealId       The dealId to which the deposits are part of\n     * @param _tokens       Array of addresses of the ERC20 tokens or ETH (ZERO address)\n     * @param _amounts      Array of amounts that are deposited\n     */\n    function multipleDeposits(\n        address _module,\n        uint32 _dealId,\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    ) external payable {\n        require(\n            _tokens.length == _amounts.length,\n            \"DaoDepositManager: Error 102\"\n        );\n        for (uint256 i; i < _tokens.length; ++i) {\n            deposit(_module, _dealId, _tokens[i], _amounts[i]);\n        }\n    }\n\n    /**\n     * @notice              Registers deposits of ERC20 tokens or ETH that have been sent\n                            to the contract directly, without envoking the method deposit().\n                            The funds will be stored with the DAO address as the depositor address\n     * @dev                 Note: if ETH has been sent, the token address for registering\n                            should be ZERO (0)\n     * @param _module       The address of the module for which is being deposited\n     * @param _dealId       The dealId to which this deposit is part of\n     * @param _token        The address of the ERC20 token or ETH (ZERO address)\n     */\n    function registerDeposit(\n        address _module,\n        uint32 _dealId,\n        address _token\n    ) public {\n        uint256 currentBalance = getBalance(_token);\n        uint256 total = tokenBalances[_token] + vestedBalances[_token];\n        if (currentBalance > total) {\n            uint256 amount = currentBalance - total;\n            tokenBalances[_token] = currentBalance;\n            availableDealBalances[_token][_module][_dealId] += amount;\n            deposits[_module][_dealId].push(\n                // solhint-disable-next-line not-rely-on-time\n                Deposit(dao, _token, amount, 0, uint32(block.timestamp))\n            );\n            emit Deposited(\n                _module,\n                _dealId,\n                dao,\n                uint32(deposits[_module][_dealId].length - 1),\n                _token,\n                amount\n            );\n        }\n        verifyBalance(_token);\n    }\n\n    /**\n     * @notice              Registers multiple deposits of ERC20 tokens and/or ETH that have been\n                            sent to the contract directly, without envoking the method deposit()\n                            or multipleDeposits(). The funds will be stored with the DAO address\n                            as the depositor address\n     * @dev                 Note: if ETH has been sent, the token address for registering\n                            should be ZERO (0)\n     * @param _module       The address of the module for which is being deposited\n     * @param _dealId       The dealId to which this deposit is part of\n     * @param _tokens       An array of ERC20 token address and/or\n                            ZERO address, symbolizing an ETH deposit\n     */\n    function registerDeposits(\n        address _module,\n        uint32 _dealId,\n        address[] calldata _tokens\n    ) external {\n        for (uint256 i; i < _tokens.length; ++i) {\n            registerDeposit(_module, _dealId, _tokens[i]);\n        }\n    }\n\n    /**\n     * @notice              Sends the token and amount, stored in the Deposit associated with the\n                            depositId to the depositor\n     * @dev                 Note: if the deposit has been registered through the function\n                            registerDeposit(), withdrawing can only happen after the periode for\n                            funding deal has been expired\n     * @param _module       The address of the module to which the dealId is part of\n     * @param _dealId       The dealId to for which the deposit has been made, that is being\n                            withdrawn\n     * @param _depositId    The ID of the deposit action (position in array)\n     * @return address      The address of the depositor\n     * @return address      The address of the ERC20 token or ETH (ZERO address)\n     * @return uint256      The available amount that is withdrawn\n     */\n    function withdraw(\n        address _module,\n        uint32 _dealId,\n        uint32 _depositId\n    )\n        external\n        returns (\n            address,\n            address,\n            uint256\n        )\n    {\n        require(\n            deposits[_module][_dealId].length > _depositId,\n            \"DaoDepositManager: Error 200\"\n        );\n        Deposit storage d = deposits[_module][_dealId][_depositId];\n\n        // Either the caller did the deposit or it's a dao deposit\n        // and the caller facilitates the withdraw for the dao\n        // (which is only possible after the deal expired)\n        require(\n            d.depositor == msg.sender ||\n                (d.depositor == dao &&\n                    IModuleBase(_module).hasDealExpired(_dealId)),\n            \"DaoDepositManager: Error 222\"\n        );\n\n        uint256 freeAmount = d.amount - d.used;\n        // Deposit can't be used by a module or withdrawn already\n        require(freeAmount > 0, \"DaoDepositManager: Error 240\");\n        d.used = d.amount;\n        availableDealBalances[d.token][_module][_dealId] -= freeAmount;\n        tokenBalances[d.token] -= freeAmount;\n        _transfer(d.token, d.depositor, freeAmount);\n\n        emit Withdrawn(\n            _module,\n            _dealId,\n            d.depositor,\n            _depositId,\n            d.token,\n            freeAmount\n        );\n        return (d.depositor, d.token, freeAmount);\n    }\n\n    /**\n     * @notice              Sends the token and amount associated with the dealId into the Deal\n                            module\n     * @param _token        The address of the ERC20 token or ETH (ZERO address)\n     * @param _amount       The amount that is sent to the module\n     */\n    function sendToModule(\n        uint32 _dealId,\n        address _token,\n        uint256 _amount\n    ) external onlyModule {\n        uint256 amountLeft = _amount;\n        for (uint256 i; i < deposits[msg.sender][_dealId].length; ++i) {\n            Deposit storage d = deposits[msg.sender][_dealId][i];\n            if (d.token == _token) {\n                uint256 freeAmount = d.amount - d.used;\n                if (freeAmount > amountLeft) {\n                    freeAmount = amountLeft;\n                }\n                amountLeft -= freeAmount;\n                d.used += freeAmount;\n\n                if (amountLeft == 0) {\n                    _transfer(_token, msg.sender, _amount);\n                    tokenBalances[_token] -= _amount;\n                    availableDealBalances[_token][msg.sender][\n                        _dealId\n                    ] -= _amount;\n                    // break out of the loop, since we sent the tokens\n                    // we now jump to the require statement at the end\n                    break;\n                }\n            }\n        }\n        require(amountLeft == 0, \"DaoDepositManager: Error 262\");\n    }\n\n    /**\n     * @notice                  Starts the vesting periode for a given token plus amount,\n                                associated to a dealId\n     * @param _token            The address of the ERC20 token or ETH (ZERO address)\n     * @param _amount           The total amount being vested\n     * @param _vestingCliff     The duration after which tokens can be claimed starting from the\n                                vesting start, in seconds\n     * @param _vestingDuration  The duration the tokens are vested, in seconds\n     */\n    function startVesting(\n        uint32 _dealId,\n        address _token,\n        uint256 _amount,\n        uint32 _vestingCliff,\n        uint32 _vestingDuration\n    ) external payable onlyModule {\n        require(_amount > 0, \"DaoDepositManager: Error 101\");\n        require(\n            _vestingCliff < _vestingDuration,\n            \"DaoDepositManager: Error 201\"\n        );\n\n        if (_token != address(0)) {\n            _transferFrom(_token, msg.sender, address(this), _amount);\n        } else {\n            require(_amount == msg.value, \"DaoDepositManager: Error 202\");\n        }\n        // no else path, since ETH will be sent by the module,\n        // which is verified by the verifyBalance() call after\n        // updating the vestedBalances\n\n        vestedBalances[_token] += _amount;\n\n        verifyBalance(_token);\n\n        vestings.push(\n            Vesting(\n                msg.sender,\n                _dealId,\n                _token,\n                _amount,\n                0,\n                // solhint-disable-next-line not-rely-on-time\n                uint32(block.timestamp),\n                _vestingCliff,\n                _vestingDuration\n            )\n        );\n\n        if (vestedTokenAmounts[_token] == 0) {\n            vestedTokenAddresses.push(_token);\n        }\n\n        vestedTokenAmounts[_token] += _amount;\n\n        // Outside of the if-clause above to catch the\n        // unlikely edge-case of multiple vestings of the\n        // same token for one deal. This is necessary\n        // for deal-based vesting claims to work.\n        ++tokensPerDeal[msg.sender][_dealId];\n\n        emit VestingStarted(\n            msg.sender,\n            _dealId,\n            // solhint-disable-next-line not-rely-on-time\n            uint32(block.timestamp),\n            _vestingCliff,\n            _vestingDuration,\n            _token,\n            _amount\n        );\n    }\n\n    /**\n     * @notice              Claims all the possible ERC20 tokens and ETH, across all deals that are\n                            part of this DaoDepositManager\n     * @dev                 This function can be called to retrieve the claimable amounts,\n                            to show in the frontend for example\n     * @return tokens       Array of addresses of the claimed tokens\n     * @return amounts      Array of amounts claimed, in the same order as the tokens array\n     */\n    function claimVestings()\n        external\n        returns (address[] memory tokens, uint256[] memory amounts)\n    {\n        uint256 vestingCount = vestedTokenAddresses.length;\n        tokens = new address[](vestingCount);\n        amounts = new uint256[](vestingCount);\n\n        // Copy storage array to memory, since the \"original\"\n        // array might change during sendReleasableClaim() if\n        // the amount of a token reaches zero\n        for (uint256 i; i < vestingCount; ++i) {\n            tokens[i] = vestedTokenAddresses[i];\n        }\n\n        for (uint256 i; i < vestings.length; ++i) {\n            (address token, uint256 amount) = sendReleasableClaim(vestings[i]);\n            for (uint256 j; j < vestingCount; ++j) {\n                if (token == tokens[j]) {\n                    amounts[j] += amount;\n                }\n            }\n        }\n        return (tokens, amounts);\n    }\n\n    /**\n     * @notice              Claims all the possible ERC20 tokens and ETH, associated with\n                            a single dealId\n     * @dev                 This function can be called to retrieve the claimable amount,\n                            to show in the frontend for example\n     * @param _module       The module address of which the dealId is part off\n     * @param _dealId       A specific deal, that is part of the dealModule\n     * @return tokens       Array of addresses of the claimed tokens, in the same order as the\n                            amounts array\n     * @return amounts      Array of amounts claimed, in the same order as the tokens array\n     */\n    function claimDealVestings(address _module, uint32 _dealId)\n        external\n        returns (address[] memory tokens, uint256[] memory amounts)\n    {\n        uint256 amountOfTokens = tokensPerDeal[_module][_dealId];\n        tokens = new address[](amountOfTokens);\n        amounts = new uint256[](amountOfTokens);\n        uint256 counter;\n        for (uint256 i; i < vestings.length; ++i) {\n            Vesting storage v = vestings[i];\n            if (v.dealModule == _module && v.dealId == _dealId) {\n                (tokens[counter], amounts[counter]) = sendReleasableClaim(v);\n                ++counter;\n            }\n        }\n        return (tokens, amounts);\n    }\n\n    /**\n     * @notice              Sends the claimable amount of the token, associated with the Vesting\n                            to the DAO address stored in the state.\n     * @param vesting       Struct containing all the information related to vesting\n     * @return token        Addresses of the claimed token\n     * @return amount       Amount of the claimable token\n     */\n    function sendReleasableClaim(Vesting memory vesting)\n        private\n        returns (address token, uint256 amount)\n    {\n        if (vesting.totalClaimed < vesting.totalVested) {\n            // Check cliff was reached\n            // solhint-disable-next-line not-rely-on-time\n            uint32 elapsedSeconds = uint32(block.timestamp) - vesting.startTime;\n\n            if (elapsedSeconds < vesting.cliff) {\n                return (vesting.token, 0);\n            }\n            if (elapsedSeconds >= vesting.duration) {\n                amount = vesting.totalVested - vesting.totalClaimed;\n                vesting.totalClaimed = vesting.totalVested;\n                tokensPerDeal[vesting.dealModule][vesting.dealId]--;\n            } else {\n                amount =\n                    (vesting.totalVested * uint256(elapsedSeconds)) /\n                    uint256(vesting.duration);\n                vesting.totalClaimed += amount;\n            }\n\n            token = vesting.token;\n            vestedTokenAmounts[token] -= amount;\n\n            // if the corresponding token doesn't have any\n            // vested amounts in any vesting anymore,\n            // we remove it from the array\n            if (vestedTokenAmounts[token] == 0) {\n                uint256 arrLen = vestedTokenAddresses.length;\n                for (uint256 i; i < arrLen; ++i) {\n                    if (vestedTokenAddresses[i] == token) {\n                        // if it's not the last element\n                        // move the last to the current slot\n                        if (i != arrLen - 1) {\n                            vestedTokenAddresses[i] = vestedTokenAddresses[\n                                arrLen - 1\n                            ];\n                        }\n                        // remove the last entry\n                        vestedTokenAddresses.pop();\n                        --arrLen;\n                    }\n                }\n            }\n\n            require(\n                vesting.totalClaimed <= vesting.totalVested,\n                \"DaoDepositManager: Error 244\"\n            );\n            vestedBalances[token] -= amount;\n            _transfer(token, dao, amount);\n\n            emit VestingClaimed(\n                vesting.dealModule,\n                vesting.dealId,\n                dao,\n                token,\n                amount\n            );\n        }\n    }\n\n    /**\n     * @notice              Verifies if the DaoDepositContract holds the balance as expected\n     * @param _token        Address of the ERC20 token or ETH (ZERO address)\n     */\n    function verifyBalance(address _token) public view {\n        require(\n            getBalance(_token) >=\n                tokenBalances[_token] + vestedBalances[_token],\n            \"DaoDepositManager: Error 245\"\n        );\n    }\n\n    /**\n     * @notice              Returns all the members in the Deposit struct for a given depositId\n     * @dev                 If ETH has been deposited, the token address returned\n                            will show ZERO (0)\n     * @param _module       The address of the module of which the dealId is part of\n     * @param _dealId       The dealId to for which the deposit has been made\n     * @param _depositId    The ID of the deposit action (position in array)\n     * @return address      The depositor address\n     * @return address      The address of the ERC20 token or ETH (ZERO address)\n     * @return uint256      The amount that has been deposited\n     * @return uint256      The amount already used in a deal\n     * @return uint32       The Unix timestamp of the deposit\n     */\n    function getDeposit(\n        address _module,\n        uint32 _dealId,\n        uint32 _depositId\n    )\n        public\n        view\n        returns (\n            address,\n            address,\n            uint256,\n            uint256,\n            uint32\n        )\n    {\n        Deposit memory d = deposits[_module][_dealId][_depositId];\n        return (d.depositor, d.token, d.amount, d.used, d.depositedAt);\n    }\n\n    /**\n     * @notice                  Returns all the members from all the Deposits within\n                                a given range of depositIds\n     * @dev                     If ETH has been deposited, the token address returned\n                                will show ZERO (0)\n     * @param _module           The address of the module of which the dealId is part of\n     * @param _dealId           The dealId to for which the deposits have been made\n     * @param _fromDepositId    First depositId (element in array) of the range IDs\n     * @param _toDepositId      Last depositId (element in array) of the range of IDs\n     * @return depositors       Array of addresses of the depositors in the deposit range\n     * @return tokens           Array of token addresses or ETH (ZERO address) in the\n                                deposit range\n     * @return amounts          Array of amounts, sorted similar as tokens array, for the given\n                                deposit range\n     * @return usedAmounts      Array of amounts already used in a deal, for the given\n                                deposit range\n     * @return times            Array of Unix timestamps of the deposits, for the given\n                                deposit range\n     */\n    function getDepositRange(\n        address _module,\n        uint32 _dealId,\n        uint32 _fromDepositId,\n        uint32 _toDepositId\n    )\n        external\n        view\n        returns (\n            address[] memory depositors,\n            address[] memory tokens,\n            uint256[] memory amounts,\n            uint256[] memory usedAmounts,\n            uint256[] memory times\n        )\n    {\n        uint32 range = 1 + _toDepositId - _fromDepositId; // inclusive range\n        depositors = new address[](range);\n        tokens = new address[](range);\n        amounts = new uint256[](range);\n        usedAmounts = new uint256[](range);\n        times = new uint256[](range);\n        uint256 index = 0; // needed since the ids can start at > 0\n        for (uint32 i = _fromDepositId; i <= _toDepositId; ++i) {\n            (\n                depositors[index],\n                tokens[index],\n                amounts[index],\n                usedAmounts[index],\n                times[index]\n            ) = getDeposit(_module, _dealId, i);\n            ++index;\n        }\n        return (depositors, tokens, amounts, usedAmounts, times);\n    }\n\n    /**\n     * @notice              Returns the stored amount of an ERC20 token or ETH, for a given deal\n     * @param _module       The address of the module to which the dealId is part of\n     * @param _dealId       The dealId that relates to the ERC20 token or ETH balance\n     * @param _token        The address of the ERC20 token or ETH (ZERO address)\n     * @return uint256      The balance amount of the ERC20 token or ETH, specific to the dealId\n     */\n    function getAvailableDealBalance(\n        address _module,\n        uint32 _dealId,\n        address _token\n    ) external view returns (uint256) {\n        return availableDealBalances[_token][_module][_dealId];\n    }\n\n    /**\n     * @notice              Returns the total number of deposits made, for a given dealId\n     * @param _module       The address of the module to which the dealId is part of\n     * @param _dealId       The dealId for which deposits have been made\n     * @return uint32       The total amount of deposits made, for a given dealId\n     */\n    function getTotalDepositCount(address _module, uint32 _dealId)\n        external\n        view\n        returns (uint32)\n    {\n        return uint32(deposits[_module][_dealId].length);\n    }\n\n    /**\n     * @notice              Returns the withdrawable amount of a specifc token and dealId,\n                            for a given address\n     * @dev                 If ETH has been deposited, the token address used should be ZERO (0)\n     * @param _module       The address of the module of which the dealId is part of\n     * @param _dealId       The dealId for which a deposit has been made, to check\n                            for withdrawable amounts\n     * @param _depositor    The address of the depositor that is able to withdraw,\n                            deposited amounts\n     * @param _token        The address of the ERC20 token or ETH (ZERO address)\n     * @return uint256      The available amount that can be withdrawn by the depositor\n     */\n    function getWithdrawableAmountOfDepositor(\n        address _module,\n        uint32 _dealId,\n        address _depositor,\n        address _token\n    ) external view returns (uint256) {\n        uint256 freeAmount;\n        for (uint256 i; i < deposits[_module][_dealId].length; ++i) {\n            if (\n                deposits[_module][_dealId][i].depositor == _depositor &&\n                deposits[_module][_dealId][i].token == _token\n            ) {\n                freeAmount += (deposits[_module][_dealId][i].amount -\n                    deposits[_module][_dealId][i].used);\n            }\n        }\n        return freeAmount;\n    }\n\n    /**\n     * @notice              Returns the balance the DaoDepositContract holds, for a given\n                            ERC20 token or ETH (ZERO address)\n     * @param _token        The address of the ERC20 token or ETH (ZERO address)\n     * @return uint256      The balance the contracts holds for the _token parameter\n     */\n    function getBalance(address _token) public view returns (uint256) {\n        if (_token == address(0)) {\n            return address(this).balance;\n        }\n        return IERC20(_token).balanceOf(address(this));\n    }\n\n    /**\n     * @notice              Returns the vested balance the DaoDepositContract holds,\n                            for a given ERC20 token or ETH (ZERO address)\n     * @param _token        The address of the ERC20 token or ETH (ZERO address)\n     * @return uint256      The vested balance the contracts holds for the _token parameter\n     */\n    function getVestedBalance(address _token) external view returns (uint256) {\n        return vestedBalances[_token];\n    }\n\n    /**\n     * @notice              Transfers the ERC20 token or ETH (ZERO address), to the _to address\n     * @param _token        The address of the ERC20 token or ETH (ZERO address)\n     * @param _to           Receiver address of the _amount of _token\n     * @param _amount       The amount to be transferred to the _to address\n     */\n    function _transfer(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) internal {\n        if (_token != address(0)) {\n            try IERC20(_token).transfer(_to, _amount) returns (bool success) {\n                require(success, \"DaoDepositManager: Error 241\");\n            } catch {\n                revert(\"DaoDepositManager: Error 241\");\n            }\n        } else {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool sent, ) = _to.call{value: _amount}(\"\");\n            require(sent, \"DaoDepositManager: Error 242\");\n        }\n    }\n\n    /**\n     * @notice              Transfers the ERC20 token or ETH (ZERO address),\n                            from the _from address to the _to address\n     * @param _token        The address of the ERC20 token or ETH (ZERO address)\n     * @param _from         The address on behalve of which the contract transfers the _token\n     * @param _to           Receiver address of the _amount of _token\n     * @param _amount       The amount to be transferred to the _to address\n     */\n    function _transferFrom(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        try IERC20(_token).transferFrom(_from, _to, _amount) returns (\n            bool success\n        ) {\n            require(success, \"DaoDepositManager: Error 241\");\n        } catch {\n            revert(\"DaoDepositManager: Error 241\");\n        }\n    }\n\n    /**\n     * @notice              Modifier that validates that the msg.sender\n                            is the DealManager contract\n     */\n    modifier onlyDealManager() {\n        require(\n            msg.sender == address(dealManager),\n            \"DaoDepositManager: Error 221\"\n        );\n        _;\n    }\n\n    /**\n     * @notice              Modifier that validates that the msg.sender\n                            is a Deals module\n     */\n    modifier onlyModule() {\n        require(\n            dealManager.addressIsModule(msg.sender),\n            \"DaoDepositManager: Error 220\"\n        );\n        _;\n    }\n\n    fallback() external payable {}\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/IDealManager.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.9;\n\ninterface IDealManager {\n    function createDaoDepositManager(address _dao) external;\n\n    function hasDaoDepositManager(address _dao) external view returns (bool);\n\n    function getDaoDepositManager(address _dao) external view returns (address);\n\n    function owner() external view returns (address);\n\n    function weth() external view returns (address);\n\n    function addressIsModule(address _address) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IModuleBase.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.9;\n\ninterface IModuleBase {\n    function moduleIdentifier() external view returns (bytes32);\n\n    function dealManager() external view returns (address);\n\n    function hasDealExpired(uint32 _dealId) external view returns (bool);\n}\n"
    },
    "contracts/DealManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/IDaoDepositManager.sol\";\nimport \"./interfaces/IModuleBase.sol\";\n\n/**\n * @title                   PrimeDeals Deal Manager\n * @notice                  Smart contract to serve as the manager\n                            for the PrimeDeals architecture\n */\ncontract DealManager is Ownable {\n    /// Address of the current implementation of the\n    /// DaoDepositManager\n    address public daoDepositManagerImplementation;\n    /// Address of the ETH wrapping contract\n    address public immutable weth;\n    /// Address DAO => address DaoDepositManager of the DAO\n    mapping(address => address) public daoDepositManager;\n    /// module address => true/false\n    mapping(address => bool) public isModule;\n\n    /**\n     * @notice                      This event is emitted when a DaoDepositManager is created\n     * @param dao                   DAO address to which the DaoDepositManager is linked\n     * @param daoDepositManager     Newly created DaoDepositManager contract address\n     */\n    event DaoDepositManagerCreated(\n        address indexed dao,\n        address indexed daoDepositManager\n    );\n\n    /**\n     * @notice                      Constructor\n     * @param _daoDepositManager    The address of the DaoDepositManager implementation\n     */\n    constructor(address _daoDepositManager, address _weth) {\n        require(\n            _daoDepositManager != address(0) &&\n                _daoDepositManager != address(this),\n            \"DealManager: Error 100\"\n        );\n        require(\n            _weth != address(0) && _weth != address(this),\n            \"DealManager: Error 100\"\n        );\n        daoDepositManagerImplementation = _daoDepositManager;\n        weth = _weth;\n    }\n\n    /**\n     * @notice                      Sets a new address for the DaoDepositManager implementation\n     * @param _newImplementation    The new address of the DaoDepositManager\n     */\n    function setDaoDepositManagerImplementation(address _newImplementation)\n        external\n        onlyOwner\n    {\n        // solhint-disable-next-line reason-string\n        require(\n            _newImplementation != address(0) &&\n                _newImplementation != address(this),\n            \"DealManager: Error 100\"\n        );\n        daoDepositManagerImplementation = _newImplementation;\n    }\n\n    /**\n     * @notice                  Activates a new Deals module\n     * @param _moduleAddress    The address of a Deals module\n     */\n    function activateModule(address _moduleAddress) external onlyOwner {\n        require(\n            _moduleAddress != address(0) && _moduleAddress != address(this),\n            \"DealManager: Error 100\"\n        );\n        require(\n            IModuleBase(_moduleAddress).dealManager() == address(this),\n            \"DealManager: Error 260\"\n        );\n\n        isModule[_moduleAddress] = true;\n    }\n\n    /**\n     * @notice                  Deactivates a Deals module\n     * @param _moduleAddress    The address of a Deals module\n     */\n    function deactivateModule(address _moduleAddress) external onlyOwner {\n        require(\n            _moduleAddress != address(0) && _moduleAddress != address(this),\n            \"DealManager: Error 100\"\n        );\n\n        isModule[_moduleAddress] = false;\n    }\n\n    /**\n     * @notice              Creates a DaoDepositManager for a DAO\n     * @param _dao          Address of the DAO for the DaoDepositContract\n     */\n    function createDaoDepositManager(address _dao) public {\n        require(\n            _dao != address(0) && _dao != address(this),\n            \"DealManager: Error 100\"\n        );\n        require(\n            daoDepositManager[_dao] == address(0),\n            \"DealManager: Error 001\"\n        );\n        require(\n            daoDepositManagerImplementation != address(0),\n            \"DealManager: Error 261\"\n        );\n        address newContract = Clones.clone(daoDepositManagerImplementation);\n        IDaoDepositManager(newContract).initialize(_dao);\n        require(\n            IDaoDepositManager(newContract).dealManager() == address(this),\n            \"DealManager: Error 260\"\n        );\n        daoDepositManager[_dao] = newContract;\n        emit DaoDepositManagerCreated(_dao, newContract);\n    }\n\n    /**\n     * @notice              Returns whether a DAO already has a DaoDepositManager\n     * @param _dao          DAO address for which to check for an existing DaoDepositManger\n     * @return bool         A bool flag indicating whether a DaoDepositManager contract exists\n     */\n    function hasDaoDepositManager(address _dao) external view returns (bool) {\n        return getDaoDepositManager(_dao) != address(0) ? true : false;\n    }\n\n    /**\n     * @notice              Returns the DaoDepositManager of a DAO\n     * @param _dao          DAO address for which to return the DaoDepositManger\n     * @return address      Address of the DaoDepositManager associated with the _dao\n     */\n    function getDaoDepositManager(address _dao) public view returns (address) {\n        return daoDepositManager[_dao];\n    }\n\n    /**\n     * @notice              Returns if the address is a Deals module\n     * @param _address      Address to check if it is a Deals module\n     * @return bool         A bool flag indicating whether the _address is a Deals module\n     */\n    function addressIsModule(address _address) external view returns (bool) {\n        return isModule[_address];\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/interfaces/IDaoDepositManager.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.9;\n\ninterface IDaoDepositManager {\n    function dealManager() external returns (address);\n\n    function initialize(address _dao) external;\n\n    function migrateBaseContract(address _newDaoDepositManager) external;\n\n    function deposit(\n        address _dealModule,\n        uint32 _dealId,\n        address _token,\n        uint256 _amount\n    ) external payable;\n\n    function multipleDeposits(\n        address _dealModule,\n        uint32 _dealId,\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    ) external payable;\n\n    function registerDeposit(\n        address _dealModule,\n        uint32 _dealId,\n        address _token\n    ) external;\n\n    function registerDeposits(\n        address _dealModule,\n        uint32 _dealId,\n        address[] calldata _tokens\n    ) external;\n\n    function withdraw(\n        address _dealModule,\n        uint32 _dealId,\n        uint32 _depositId,\n        address _sender\n    )\n        external\n        returns (\n            address,\n            address,\n            uint256\n        );\n\n    function sendToModule(\n        uint32 _dealId,\n        address _token,\n        uint256 _amount\n    ) external;\n\n    function startVesting(\n        uint32 _dealId,\n        address _token,\n        uint256 _amount,\n        uint32 _vestingCliff,\n        uint32 _vestingDuration\n    ) external payable;\n\n    function claimVestings() external;\n\n    function verifyBalance(address _token) external view;\n\n    function getDeposit(\n        address _dealModule,\n        uint32 _dealId,\n        uint32 _depositId\n    )\n        external\n        view\n        returns (\n            address,\n            address,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function getAvailableDealBalance(\n        address _dealModule,\n        uint32 _dealId,\n        address _token\n    ) external view returns (uint256);\n\n    function getTotalDepositCount(address _dealModule, uint32 _dealId)\n        external\n        view\n        returns (uint256);\n\n    function getWithdrawableAmountOfDepositor(\n        address _dealModule,\n        uint32 _dealId,\n        address _user,\n        address _token\n    ) external view returns (uint256);\n\n    function getBalance(address _token) external view returns (uint256);\n\n    function getVestedBalance(address _token) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/modules/ModuleBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IDaoDepositManager.sol\";\nimport \"../interfaces/IDealManager.sol\";\n\n/**\n * @title                   PrimeDeals Module Base\n * @notice                  Smart contract to serve as the\n                            basis for each module\n */\ncontract ModuleBase {\n    /// Address of the DealManager implementation\n    IDealManager public immutable dealManager;\n\n    /**\n     * @notice              Constructor\n     * @param _dealManager  The address of DealManager implementation\n     */\n    constructor(address _dealManager) {\n        require(_dealManager != address(0), \"ModuleBase: Error 100\");\n        dealManager = IDealManager(_dealManager);\n    }\n\n    /**\n      * @notice             Sends tokens from a DAO deposit manager to the module\n      * @param _dealId      ID of the action this is related to\n      * @param _daos        Array containing the DAOs that are involed in this action\n      * @param _tokens      Array containing the tokens that are involed in this action\n      * @param _path        Double nested array containing the amounts of tokens for each\n                            token for each dao to be send\n      * @return amountsIn   Array containing the total amounts sent per token\n    */\n    function _pullTokensIntoModule(\n        uint32 _dealId,\n        address[] memory _daos,\n        address[] memory _tokens,\n        uint256[][] memory _path\n    ) internal returns (uint256[] memory amountsIn) {\n        amountsIn = new uint256[](_tokens.length);\n        require(_path.length == _tokens.length, \"ModuleBase: Error 102\");\n        for (uint256 i; i < _tokens.length; ++i) {\n            uint256[] memory tokenPath = _path[i];\n            require(tokenPath.length == _daos.length, \"ModuleBase: Error 102\");\n            for (uint256 j; j < tokenPath.length; ++j) {\n                uint256 daoAmount = tokenPath[j];\n                if (daoAmount > 0) {\n                    amountsIn[i] += daoAmount;\n                    IDaoDepositManager(\n                        dealManager.getDaoDepositManager(_daos[j])\n                    ).sendToModule(_dealId, _tokens[i], daoAmount);\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice              Calls the approval function of a token\n     * @param _token        Address of the token\n     * @param _to           Target of the approval\n     * @param _amount       Amount to be approved\n     */\n    function _approveToken(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) internal {\n        require(IERC20(_token).approve(_to, _amount), \"ModuleBase: Error 243\");\n    }\n\n    /**\n     * @notice              Calls the approval function of a token\n                            for the deposit manager of a DAO\n     * @param _token        Address of the token\n     * @param _dao          DAO whose deposit manager is the target\n     * @param _amount       Amount to be approved\n     */\n    function _approveDaoDepositManager(\n        address _token,\n        address _dao,\n        uint256 _amount\n    ) internal {\n        _approveToken(_token, dealManager.getDaoDepositManager(_dao), _amount);\n    }\n\n    /**\n     * @notice              Transfers an amount of tokens\n     * @param _token        Address of the token\n     * @param _to           Target of the transfer\n     * @param _amount       Amount to be sent\n     */\n    function _transfer(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) internal {\n        if (_token != address(0)) {\n            try IERC20(_token).transfer(_to, _amount) returns (bool success) {\n                require(success, \"ModuleBase: Error 241\");\n            } catch {\n                revert(\"ModuleBase: Error 241\");\n            }\n        } else {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool sent, ) = _to.call{value: _amount}(\"\");\n            require(sent, \"ModuleBase: Error 242\");\n        }\n    }\n\n    /**\n     * @notice              Transfers an amount of tokens from an address\n     * @param _token        Address of the token\n     * @param _from         Source of the transfer\n     * @param _to           Target of the transfer\n     * @param _amount       Amount to be sent\n     */\n    function _transferFrom(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        require(_token != address(0), \"ModuleBase: Error 263\");\n\n        try IERC20(_token).transferFrom(_from, _to, _amount) returns (\n            bool success\n        ) {\n            require(success, \"ModuleBase: Error 241\");\n        } catch {\n            revert(\"ModuleBase: Error 241\");\n        }\n    }\n\n    /**\n     * @notice              Checks if the deal has been expired\n     * @param _dealId       The dealId of the action (position in the array)\n     * @return bool         A bool flag indiciating whether deal has expired\n     */\n    function hasDealExpired(uint32 _dealId)\n        public\n        view\n        virtual\n        returns (bool)\n    // solhint-disable-next-line no-empty-blocks\n    {\n\n    }\n}\n"
    },
    "contracts/modules/ModuleBaseWithFee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.9;\n\nimport \"./ModuleBase.sol\";\n\n/**\n * @title                   PrimeDeals Module Base Fee Extension\n * @notice                  Smart contract to extend the module\n                            base with a fee mechanim\n */\ncontract ModuleBaseWithFee is ModuleBase {\n    /// Wallet that is receiving the fees\n    address public feeWallet;\n    /// Fee in basis points (100% = 10000)\n    uint32 public feeInBasisPoints;\n    // Max fee 20%\n    // solhint-disable-next-line var-name-mixedcase\n    uint32 public immutable MAX_FEE = 2000;\n\n    // Percentage precision to calculate the fee\n    // solhint-disable-next-line var-name-mixedcase\n    uint256 public immutable BPS = 10000;\n\n    /**\n     * @notice              Constructor\n     * @param _dealManager  The address of Dealmanager implementation\n     */\n    // solhint-disable-next-line no-empty-blocks\n    constructor(address _dealManager) ModuleBase(_dealManager) {}\n\n    /**\n     * @notice              This event is emitted when the fee wallet address is updated\n     * @param oldFeeWallet  Address of the old fee wallet\n     * @param newFeeWallet  Address of the new fee wallet\n     */\n    event FeeWalletChanged(\n        address indexed oldFeeWallet,\n        address indexed newFeeWallet\n    );\n\n    /**\n     * @notice              This event is emitted when the fee is updated\n     * @param oldFee        Old fee amount in basis points (1% = 100)\n     * @param newFee        New fee in basis points (1% = 100) that is updated\n     */\n    event FeeChanged(uint32 indexed oldFee, uint32 indexed newFee);\n\n    /**\n     * @notice              Sets a new fee wallet\n     * @param _feeWallet    Address of the new fee wallet\n     * @dev                 The fee system will be inactive if the feeWallet\n                            is set to a zero-address\n     */\n    function setFeeWallet(address _feeWallet)\n        external\n        onlyDealManagerOwner(msg.sender)\n    {\n        require(\n            _feeWallet != address(0) && _feeWallet != address(this),\n            \"ModuleBaseWithFee: Error 100\"\n        );\n        if (feeWallet != _feeWallet) {\n            feeWallet = _feeWallet;\n            emit FeeWalletChanged(feeWallet, _feeWallet);\n        }\n    }\n\n    /**\n     * @notice                      Sets a new fee\n     * @param _feeInBasisPoints     Fee amount in basis points (1% = 100)\n     */\n    function setFee(uint32 _feeInBasisPoints)\n        external\n        onlyDealManagerOwner(msg.sender)\n    {\n        require(_feeInBasisPoints <= MAX_FEE, \"ModuleBaseWithFee: Error 264\");\n        if (feeInBasisPoints != _feeInBasisPoints) {\n            feeInBasisPoints = _feeInBasisPoints;\n            emit FeeChanged(feeInBasisPoints, _feeInBasisPoints);\n        }\n    }\n\n    /**\n     * @notice              Pays the fee in a token and returns the remainder\n     * @param _token        Token in which the transfer happens\n     * @param _amount       Amount of the transfer\n     * @return uint256      Remaining amount after the fee payment\n     */\n    function _payFeeAndReturnRemainder(address _token, uint256 _amount)\n        internal\n        returns (uint256)\n    {\n        if (feeWallet != address(0) && feeInBasisPoints > 0) {\n            uint256 fee = (_amount * feeInBasisPoints) / BPS;\n            _transfer(_token, feeWallet, fee);\n\n            return _amount - fee;\n        }\n        return _amount;\n    }\n\n    /**\n     * @notice                  Transfers a token amount with automated fee payment\n     * @param _token            Token in which the transfer happens\n     * @param _to               Target of the transfer\n     * @param _amount           Amount of the transfer\n     * @return amountAfterFee   The amount minus the fee\n     */\n    function _transferWithFee(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) internal returns (uint256 amountAfterFee) {\n        amountAfterFee = _payFeeAndReturnRemainder(_token, _amount);\n        _transfer(_token, _to, amountAfterFee);\n    }\n\n    /**\n     * @notice                  Transfers a token amount from someone with automated fee payment\n     * @param _token            Token in which the transfer happens\n     * @param _from             Source of the transfer\n     * @param _to               Target of the transfer\n     * @param _amount           Amount of the transfer\n     * @return amountAfterFee   The amount minus the fee\n     */\n    function _transferFromWithFee(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal returns (uint256 amountAfterFee) {\n        // if the transfer from does not touch this contract, we first\n        // need to transfer it here, pay the fee, and then pass it on\n        // if that is not the case, we can do the regular transferFrom\n        if (_to != address(this)) {\n            _transferFrom(_token, _from, address(this), _amount);\n            amountAfterFee = _transferWithFee(_token, _to, _amount);\n        } else {\n            _transferFrom(_token, _from, _to, _amount);\n            amountAfterFee = _payFeeAndReturnRemainder(_token, _amount);\n        }\n    }\n\n    /**\n     * @notice              Modifier that validates that the msg.sender\n                            is the DealManager contract\n     * @param _sender       Msg.sender of the function that is called\n     */\n    modifier onlyDealManagerOwner(address _sender) {\n        require(_sender == dealManager.owner(), \"ModuleBaseWithFee: Error 221\");\n        _;\n    }\n}\n"
    },
    "contracts/modules/tokenswap/TokenSwapModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.9;\n\nimport \"../ModuleBaseWithFee.sol\";\n\n/**\n * @title                   PrimeDeals Token Swap Module\n * @notice                  Smart contract to handle token swap\n                            interactions for PrimeDeals\n */\ncontract TokenSwapModule is ModuleBaseWithFee {\n    /// Array of token swaps where the index == dealId\n    TokenSwap[] public tokenSwaps;\n    /// Metadata => deal ID\n    mapping(bytes32 => uint32) public metadataToDealId;\n\n    /**\n     * @dev\n     * pathFrom Description:\n     * Used to storing how many tokens does each DAO send to the module\n     *\n     * Example on how the values are stored:\n     * token -> DAO -> amount\n     * [[123, 0, 123], [0, 123, 0]]\n     * token 1: DAO 1 sends 123, DAO 2 sends 0, DAO 3 sends 123, etc.\n     *\n     * pathTo Description:\n     * Used for storing how many tokens does each DAO receive from the module\n     * includes vesting. For each DAO there is a tuple of four values:\n     * instant amount, vested amount, vesting cliff, vesting duration.\n     * The start time will be the block.timestamp when executing the deal.\n     * This timestamp + vestingDuration can be used to calculate the vesting end.\n     *\n     * Example on how the values are stored:\n     * token -> DAO -> tuple(4)\n     * [[instantAmount_dao1, vestedAmount_dao1, vestingCliff_dao1,\n     * vestingDuration_dao1, instantAmount_dao2, ...], [...]]\n     */\n    struct TokenSwap {\n        /// The participating DAOs\n        address[] daos;\n        /// The tokens involved in the swap\n        address[] tokens;\n        /// The token flow from the DAOs to the module, see above\n        uint256[][] pathFrom;\n        /// The token flow from the module to the DAO, see above\n        uint256[][] pathTo;\n        /// Amount of time in seconds the token swap can be executed\n        uint32 deadline;\n        /// Unix timestamp of the execution\n        uint32 executionDate;\n        /// Hash of the deal information.\n        bytes32 metadata;\n        // boolean to check if the deal has been executed\n        bool isExecuted;\n    }\n\n    /**\n     * @notice              This event is emitted when a token swap is created\n     * @param module        Address of this module\n     * @param dealId        Deal id for the created token swap\n     * @param metadata      Unique ID that is generated throught the Prime Deals frontend\n     * @param daos          Array containing the DAOs that are involed in creating the token swap\n     * @param tokens        Array containing the tokens that are involed in creating the token swap\n     * @param pathFrom      Two-dimensional array containing the tokens flowing from the\n                            DAOs into the module\n     * @param pathTo        Two-dimensional array containing the tokens flowing from the\n                            module to the DAOs\n     * @param deadline      The amount of time between the creation of the swap and the time when\n                            it can no longer be executed, in seconds\n     */\n    event TokenSwapCreated(\n        address indexed module,\n        uint32 indexed dealId,\n        bytes32 indexed metadata,\n        address[] daos,\n        address[] tokens,\n        uint256[][] pathFrom,\n        uint256[][] pathTo,\n        uint32 deadline\n    );\n\n    /**\n     * @notice              This event is emitted when a token swap is executed\n     * @param module        Address of this module\n     * @param dealId        Deal id for the executed token swap\n     * @param metadata      Unique ID that is generated throught the Prime Deals frontend\n     */\n    event TokenSwapExecuted(\n        address indexed module,\n        uint32 indexed dealId,\n        bytes32 indexed metadata\n    );\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor(address _dealManager) ModuleBaseWithFee(_dealManager) {}\n\n    /**\n      * @notice             Creates a new token swap action\n      * @param _daos        Array containing the DAOs that are involed in this action\n      * @param _tokens      Array containing the tokens that are involed in this action\n      * @param _pathFrom    Two-dimensional array containing the tokens flowing from the\n                            DAOs into the module:\n                              - First array level is for each token\n                              - Second array level is for each dao\n                              - Detailed overview on how to configure the array can be found at the\n                                TokenSwap struct description\n      * @param _pathTo      Two-dimensional array containing the tokens flowing from the\n                            module to the DAOs:\n                              - First array level is for each token\n                              - Second array level is for each dao\n                              - Detailed overview on how to configure the array can be found at the\n                                TokenSwap struct description\n      * @param _metadata    Unique ID that is generated throught the Prime Deals frontend\n      * @param _deadline    The amount of time between the creation of the swap and the time when\n                            it can no longer be executed, in seconds\n      * @return uint32      The dealId of the new token swap\n    */\n    function _createSwap(\n        address[] memory _daos,\n        address[] memory _tokens,\n        uint256[][] memory _pathFrom,\n        uint256[][] memory _pathTo,\n        bytes32 _metadata,\n        uint32 _deadline\n    ) internal returns (uint32) {\n        require(_metadata != \"\", \"TokenSwapModule: Error 101\");\n        require(\n            tokenSwaps.length == 0 || _metadataDoesNotExist(_metadata),\n            \"TokenSwapModule: Error 203\"\n        );\n        require(_daos.length >= 2, \"TokenSwapModule: Error 204\");\n        require(_tokens.length != 0, \"TokenSwapModule: Error 205\");\n        require(_deadline > 0, \"TokenSwapModule: Error 101\");\n\n        // Check outer arrays\n        uint256 pathFromLen = _pathFrom.length;\n        require(\n            _tokens.length == pathFromLen && pathFromLen == _pathTo.length,\n            \"TokenSwapModule: Error 102\"\n        );\n\n        // Check inner arrays\n        uint256 daosLen = _daos.length;\n        for (uint256 i; i < pathFromLen; ++i) {\n            require(\n                _pathFrom[i].length == daosLen &&\n                    _pathTo[i].length == daosLen << 2,\n                \"TokenSwapModule: Error 102\"\n            );\n        }\n\n        TokenSwap memory ts = TokenSwap(\n            _daos,\n            _tokens,\n            _pathFrom,\n            _pathTo,\n            // solhint-disable-next-line not-rely-on-time\n            uint32(block.timestamp) + _deadline,\n            0,\n            _metadata,\n            false\n        );\n        tokenSwaps.push(ts);\n\n        uint32 dealId = uint32(tokenSwaps.length - 1);\n\n        metadataToDealId[_metadata] = dealId;\n\n        emit TokenSwapCreated(\n            address(this),\n            dealId,\n            _metadata,\n            _daos,\n            _tokens,\n            _pathFrom,\n            _pathTo,\n            _deadline\n        );\n        return dealId;\n    }\n\n    /**\n      * @notice             Create a new token swap action and automatically\n                            creates Dao Deposit Manager for each DAO that does not have one\n      * @param _daos        Array containing the DAOs that are involed in this action\n      * @param _tokens      Array containing the tokens that are involed in this action\n      * @param _pathFrom    Two-dimensional array containing the tokens flowing from the\n                            DAOs into the module:\n                              - First array level is for each token\n                              - Second array level is for each dao\n                              - Detailed overview on how to configure the array can be found at the\n                                TokenSwap struct description\n      * @param _pathTo      Two-dimensional array containing the tokens flowing from the\n                            module to the DAOs:\n                              - First array level is for each token\n                              - Second array level is for each dao\n                              - Detailed overview on how to configure the array can be found at the\n                                TokenSwap struct description\n      * @param _metadata    Unique ID that is generated throught the Prime Deals frontend\n      * @param _deadline    The amount of time between the creation of the swap and the time when\n                            it can no longer be executed, in seconds\n      * @return uin32       The dealId of the new token swap\n    */\n    function createSwap(\n        address[] calldata _daos,\n        address[] calldata _tokens,\n        uint256[][] calldata _pathFrom,\n        uint256[][] calldata _pathTo,\n        bytes32 _metadata,\n        uint32 _deadline\n    ) external returns (uint32) {\n        for (uint256 i; i < _daos.length; ++i) {\n            address dao = _daos[i];\n            if (!dealManager.hasDaoDepositManager(dao)) {\n                dealManager.createDaoDepositManager(dao);\n            }\n        }\n        return (\n            _createSwap(\n                _daos,\n                _tokens,\n                _pathFrom,\n                _pathTo,\n                _metadata,\n                _deadline\n            )\n        );\n    }\n\n    /**\n      * @notice             Checks whether a token swap action can be executed, which is the case\n                            if all DAOs have deposited\n      * @param _dealId      The dealId of the action (position in the array)\n      * @return bool        A bool flag indiciating whether the action can be executed\n    */\n    function checkExecutability(uint32 _dealId)\n        public\n        view\n        validDealId(_dealId)\n        returns (bool)\n    {\n        TokenSwap memory ts = tokenSwaps[_dealId];\n        if (hasDealExpired(_dealId)) {\n            return false;\n        }\n\n        address[] memory t = ts.tokens;\n        for (uint256 i; i < t.length; ++i) {\n            uint256[] memory p = ts.pathFrom[i];\n            for (uint256 j; j < p.length; ++j) {\n                if (p[j] == 0) {\n                    continue;\n                }\n                // for each token and each pathFrom entry for this\n                // token, check whether the corresponding DAO\n                // has deposited the corresponding amount into their\n                // deposit contract\n                uint256 bal = IDaoDepositManager(\n                    dealManager.getDaoDepositManager(ts.daos[j])\n                ).getAvailableDealBalance(address(this), _dealId, t[i]);\n                if (bal < p[j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice              Executes a token swap action\n     * @param _dealId       The dealId of the action (position in the array)\n     */\n    function executeSwap(uint32 _dealId)\n        external\n        validDealId(_dealId)\n        isNotExecuted(_dealId)\n    {\n        TokenSwap storage ts = tokenSwaps[_dealId];\n\n        require(checkExecutability(_dealId), \"TokenSwapModule: Error 265\");\n\n        // transfer the tokens from the deposit manager of the DAOs\n        // into this module\n        uint256[] memory amountsIn = _pullTokensIntoModule(\n            _dealId,\n            ts.daos,\n            ts.tokens,\n            ts.pathFrom\n        );\n\n        // distribute the tokens from this module to the DAOs\n        // and (if applicable) and their vesting contracts\n        uint256[] memory amountsOut = _distributeTokens(ts, _dealId);\n\n        // verify whether the amounts being pulled and pushed match\n        for (uint256 i; i < ts.tokens.length; ++i) {\n            require(\n                amountsIn[i] == amountsOut[i],\n                \"TokenSwapModule: Error 103\"\n            );\n        }\n\n        ts.isExecuted = true;\n        // solhint-disable-next-line not-rely-on-time\n        ts.executionDate = uint32(block.timestamp);\n        emit TokenSwapExecuted(address(this), _dealId, ts.metadata);\n    }\n\n    /**\n      * @notice             Distributes the tokens based on the supplied information to the DAOs\n                            or their vesting contracts\n      * @param _ts          TokenSwap object containing all the information of the action\n      * @param _dealId      The dealId of the action (position in the array)\n      * @return amountsOut  The two min values for the token amounts _ts\n    */\n    function _distributeTokens(TokenSwap memory _ts, uint32 _dealId)\n        internal\n        returns (uint256[] memory amountsOut)\n    {\n        amountsOut = new uint256[](_ts.tokens.length);\n        // Distribute tokens from the module\n        for (uint256 i; i < _ts.tokens.length; ++i) {\n            uint256[] memory pt = _ts.pathTo[i];\n            address token = _ts.tokens[i];\n            for (uint256 k; k < pt.length >> 2; ++k) {\n                // every 4 values, the values for a new dao start\n                // value 0 = instant amount\n                // value 1 = vested amount\n                // value 2 = vesting cliff\n                // value 3 = vesting duration\n                uint256 instant = pt[k << 2];\n                uint256 vested = pt[(k << 2) + 1];\n\n                if (instant > 0) {\n                    amountsOut[i] += instant;\n                    _transferWithFee(token, _ts.daos[k], instant);\n                }\n\n                if (vested > 0) {\n                    amountsOut[i] += vested;\n                    uint256 amount = _payFeeAndReturnRemainder(token, vested);\n                    address daoDepositManager = dealManager\n                        .getDaoDepositManager(_ts.daos[k]);\n                    if (token != address(0)) {\n                        _approveDaoDepositManager(token, _ts.daos[k], amount);\n                    }\n\n                    IDaoDepositManager(daoDepositManager).startVesting{\n                        value: token == address(0) ? amount : 0\n                    }(\n                        _dealId,\n                        token,\n                        amount, // amount\n                        uint32(pt[(k << 2) + 2]), // start\n                        uint32(pt[(k << 2) + 3]) // end\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice              Returns the TokenSwap struct associated with the metadata\n     * @param _metadata     Unique ID that is generated throught the Prime Deals frontend\n     * @return swap         Token swap struct associated with the metadata\n     */\n    function getTokenswapFromMetadata(bytes32 _metadata)\n        public\n        view\n        returns (TokenSwap memory swap)\n    {\n        uint256 dealId = metadataToDealId[_metadata];\n        require(\n            dealId != 0 ||\n                (tokenSwaps[dealId].metadata == _metadata && _metadata != \"\"),\n            \"TokenSwapModule: Error 206\"\n        );\n        return tokenSwaps[metadataToDealId[_metadata]];\n    }\n\n    /**\n     * @notice              Checks if the deal has been expired\n     * @param _dealId       The dealId of the action (position in the array)\n     * @return bool         A bool flag indiciating whether token swap has expired\n     */\n    function hasDealExpired(uint32 _dealId)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return\n            tokenSwaps[_dealId].isExecuted ||\n            // solhint-disable-next-line not-rely-on-time\n            tokenSwaps[_dealId].deadline < uint32(block.timestamp);\n    }\n\n    /**\n     * @notice              Checks if the given metadata is Unique, and not already used\n     * @param _metadata     Unique ID that is generated throught the Prime Deals frontend\n     * @return bool         A bool flag indiciating whether the metadata is unique\n     */\n    function _metadataDoesNotExist(bytes32 _metadata)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 dealId = metadataToDealId[_metadata];\n        return (dealId == 0 && tokenSwaps[dealId].metadata != _metadata);\n    }\n\n    /**\n     * @notice              Modifier that validates if the given deal ID is valid\n     * @param _dealId       The dealId of the action (position in the array)\n     */\n    modifier validDealId(uint32 _dealId) {\n        require(_dealId < tokenSwaps.length, \"TokenSwapModule: Error 207\");\n        _;\n    }\n\n    /**\n     * @notice              Modifier that validates if token swap has not been executed\n     * @param _dealId       The dealId of the action (position in the array)\n     */\n    modifier isNotExecuted(uint32 _dealId) {\n        require(!tokenSwaps[_dealId].isExecuted, \"TokenSwapModule: Error 266\");\n        _;\n    }\n\n    fallback() external payable {}\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n"
    },
    "contracts/modules/liquidity/uniswap/LiquidityModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.9;\n\nimport \"../../ModuleBaseWithFee.sol\";\nimport \"../../../interfaces/IUniswapV2Router02.sol\";\nimport \"../../../interfaces/IUniswapV2Factory.sol\";\nimport \"../../../interfaces/IWETH.sol\";\n\n/**\n * @title PrimeDeals Liquidity Module (Uniswap)\n * @dev   Smart contract to handle liquidity pool\n *        interactions for PrimeDeals\n */\ncontract LiquidityModule_Uniswap is ModuleBaseWithFee {\n    IUniswapV2Router02 public router;\n    IUniswapV2Factory public factory;\n\n    LiquidityAction[] public liquidityActions;\n\n    struct LiquidityAction {\n        // the participating DAOs\n        address[] daos;\n        // the tokens involved in the action\n        address[] tokens;\n        // the token flow from the DAOs to the module\n        uint256[][] pathFrom;\n        // the lp token flow from the module to the DAO\n        uint256[] pathTo;\n        // the maximum difference between the\n        // token ratio from pathFrom and the\n        // actual ratio on-chain in basis points\n        // (1% = 100)\n        uint256 maxDiff;\n        // unix timestamp of the deadline\n        uint32 deadline;\n        // unix timestamp of the execution\n        uint32 executionDate;\n        // status of the deal\n        bool isExecuted;\n    }\n\n    // pathFrom:\n    // how much tokens does each dao send to the module\n    // token -> dao -> amount\n    // [[123, 0, 123], [0, 123, 0]]\n    // token 1: dao 1 sends 123, dao 2 sends 0, dao 3 sends 123, etc.\n\n    // pathFrom:\n    // how much lp tokens does each dao receive\n    // from the module, includes vesting.\n    // since we do not know the amount of the LP tokens in any case\n    // we use percentage values here in basis points, so\n    // 1% = 100\n    // token -> dao -> tuple(4)\n    // [[instantAmount_dao1, vestedAmount_dao1, vestingStart_dao1,\n    // vestingEnd_dao1, instantAmount_dao2, ...], [...]]\n\n    event LiquidityActionCreated(\n        uint32 dealId,\n        address[] _daos,\n        address[] _tokens,\n        uint256[][] _pathFrom,\n        uint256[] _pathTo,\n        uint256 _maxDiff,\n        uint32 _deadline\n    );\n\n    event LiquidityActionCancelled(uint32 dealId);\n\n    event LiquidityActionDeadlineExtended(uint32 dealId, uint32 newDeadline);\n\n    event LiquidityActionExecuted(uint32 dealId);\n\n    constructor(address _dealManager, address _router)\n        ModuleBaseWithFee(_dealManager)\n    {\n        require(_router != address(0), \"Module: invalid router address\");\n        router = IUniswapV2Router02(_router);\n        factory = IUniswapV2Factory(router.factory());\n    }\n\n    /**\n      * @dev                Create a new liquidity pool related action\n      * @param _daos        Array containing the DAOs that are involed in this action\n      * @param _tokens      Array containing the tokens that are involed in this action\n      * @param _pathFrom    Two-dimensional array containing the tokens flowing from the\n                            DAOs into the module:\n                              - First array level is for each token\n                              - Second array level is for each dao\n                              - Contains absolute numbers of tokens\n      * @param _pathTo      Array containing the resulting LP tokens flowing to the DAOs\n                              - Contains percentage numbers of tokens\n                              - In Basis Points (1% = 100) \n      * @param _maxDiff     The maximum difference between the ratio resulting from the \n                            pathFrom and the actual balance of the pool (if it already \n                            exists)\n                              - In Basis Points (1% = 100) \n      * @param _deadline    Time until which this action can be executed (unix timestamp)\n      * @return             The ID of the new action\n    */\n    function createLiquidityAction(\n        address[] calldata _daos,\n        address[] calldata _tokens,\n        uint256[][] calldata _pathFrom,\n        uint256[] calldata _pathTo,\n        uint256 _maxDiff,\n        uint32 _deadline\n    ) public returns (uint32) {\n        require(_daos.length >= 2, \"Module: at least 2 daos required\");\n\n        require(\n            _tokens.length == 2,\n            \"Module: only exactly two tokens supported\"\n        );\n\n        require(_maxDiff <= 10000, \"Module: maxDiff can't be more than 100%\");\n\n        require(\n            _pathFrom.length == _pathTo.length &&\n                _pathFrom[0].length == _daos.length &&\n                _pathTo.length >> 2 == _daos.length,\n            \"Module: invalid array lengths\"\n        );\n\n        require(_deadline > block.timestamp, \"Module: invalid deadline\");\n\n        LiquidityAction memory la = LiquidityAction(\n            _daos,\n            _tokens,\n            _pathFrom,\n            _pathTo,\n            _maxDiff,\n            _deadline,\n            0,\n            false\n        );\n        liquidityActions.push(la);\n\n        uint32 dealId = uint32(liquidityActions.length - 1);\n        emit LiquidityActionCreated(\n            dealId,\n            _daos,\n            _tokens,\n            _pathFrom,\n            _pathTo,\n            _maxDiff,\n            _deadline\n        );\n\n        return dealId;\n    }\n\n    /**\n      * @dev                Create a new liquidity pool related action and automatically\n                            creates Deposit Contracts for each DAO that does not have one\n      * @param _daos        Array containing the DAOs that are involed in this action\n      * @param _tokens      Array containing the tokens that are involed in this action\n      * @param _pathFrom    Two-dimensional array containing the tokens flowing from the\n                            DAOs into the module:\n                              - First array level is for each token\n                              - Second array level is for each dao\n                              - Contains absolute numbers of tokens\n      * @param _pathTo      Array containing the resulting LP tokens flowing to the DAOs\n                              - Contains percentage numbers of tokens\n                              - In Basis Points (1% = 100) \n      * @param _maxDiff     The maximum difference between the ratio resulting from the \n                            pathFrom and the actual balance of the pool (if it already \n                            exists)\n                              - In Basis Points (1% = 100) \n      * @param _deadline    Time until which this action can be executed (unix timestamp)\n      * @return             The ID of the new action\n    */\n    function createDepositContractsAndCreateLiquidityAction(\n        address[] calldata _daos,\n        address[] calldata _tokens,\n        uint256[][] calldata _pathFrom,\n        uint256[] calldata _pathTo,\n        uint256 _maxDiff,\n        uint32 _deadline\n    ) external returns (uint32) {\n        for (uint256 i; i < _daos.length; ++i) {\n            if (!dealManager.hasDaoDepositManager(_daos[i])) {\n                dealManager.createDaoDepositManager(_daos[i]);\n            }\n        }\n\n        return\n            createLiquidityAction(\n                _daos,\n                _tokens,\n                _pathFrom,\n                _pathTo,\n                _maxDiff,\n                _deadline\n            );\n    }\n\n    /**\n      * @dev            Checks whether a liquidity action can be executed\n                        (which is the case if all DAOs have deposited)\n      * @param _dealId      The ID of the action (position in the array)\n      * @return         A bool flag indiciating whether the action can be executed\n    */\n    function checkExecutability(uint32 _dealId)\n        external\n        view\n        validId(_dealId)\n        returns (bool)\n    {\n        LiquidityAction memory la = liquidityActions[_dealId];\n        if (la.isExecuted) {\n            return false;\n        }\n\n        if (la.deadline < uint32(block.timestamp)) {\n            return false;\n        }\n        for (uint256 i; i < la.tokens.length; ++i) {\n            for (uint256 j; j < la.pathFrom[i].length; ++j) {\n                // for each token and each pathFrom entry for this\n                // token, check whether the corresponding DAO\n                // has deposited the corresponding amount into their\n                // deposit contract\n                if (\n                    IDaoDepositManager(\n                        dealManager.getDaoDepositManager(la.daos[j])\n                    ).getAvailableDealBalance(\n                            address(this),\n                            _dealId,\n                            la.tokens[i]\n                        ) < la.pathFrom[i][j]\n                ) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev            Executes a liquidity action\n     * @param _dealId      The ID of the action (position in the array)\n     */\n    function executeLiquidityAction(uint32 _dealId)\n        external\n        validId(_dealId)\n        isNotExecuted(_dealId)\n    {\n        LiquidityAction memory la = liquidityActions[_dealId];\n\n        require(\n            la.deadline >= uint32(block.timestamp),\n            \"Module: action expired\"\n        );\n\n        // Collect tokens into the module\n        uint256[] memory tokenAmountsIn = _pullTokensIntoModule(\n            _dealId,\n            la.daos,\n            la.tokens,\n            la.pathFrom\n        );\n\n        for (uint256 i; i < la.tokens.length; ++i) {\n            if (la.tokens[i] == address(0)) {\n                address weth = dealManager.weth();\n                IWETH(weth).deposit{value: tokenAmountsIn[i]}();\n                la.tokens[i] = weth;\n            }\n            _approveToken(la.tokens[i], address(router), tokenAmountsIn[i]);\n        }\n\n        // Returns the min amounts for both tokens\n        // based on the current balance of the pool\n        // (if there are tokens already) and the\n        // maxDiff variable\n        (uint256 minA, uint256 minB) = _evaluateLPDetails(\n            la.tokens[0],\n            la.tokens[1],\n            tokenAmountsIn[0],\n            tokenAmountsIn[1],\n            la.maxDiff,\n            factory.getPair(la.tokens[0], la.tokens[1])\n        );\n\n        // Create Liquidity Position\n        (uint256 usedAmountA, uint256 usedAmountB, uint256 lpTokens) = router\n            .addLiquidity(\n                la.tokens[0],\n                la.tokens[1],\n                tokenAmountsIn[0],\n                tokenAmountsIn[1],\n                minA,\n                minB,\n                address(this),\n                la.deadline\n            );\n\n        // Store any leftover amounts\n        tokenAmountsIn[0] -= usedAmountA;\n        tokenAmountsIn[1] -= usedAmountB;\n\n        // Distribute the obtained LP tokens\n        // and return the percentage share of each DAO\n        // of the LP payouts\n        // also distributes any leftover from the original\n        // tokens according to the share of each DAO\n        _distributeTokens(\n            _dealId,\n            la,\n            factory.getPair(la.tokens[0], la.tokens[1]),\n            lpTokens,\n            tokenAmountsIn\n        );\n\n        la.isExecuted = true;\n        la.executionDate = uint32(block.timestamp);\n        emit LiquidityActionExecuted(_dealId);\n    }\n\n    /**\n      * @dev                    Verifies whether the pool ratio resulting from the pathFrom\n                                and the actual balance of the pool (if it already exists)\n                                match based on the maxDiff value\n      * @param _tokenA          Address of the first token\n      * @param _tokenB          Address of the second token\n      * @param _amountA         Amount of the first token\n      * @param _amountB         Amount of the second token\n      * @param _maxDiff         The maximum difference between the ratio resulting from the \n                                pathFrom and the actual balance of the pool (if it already \n                                xists)\n      * @param _poolContract    The address of the new pool contract\n      * @return                 The two min values for the token amounts\n    */\n    function _evaluateLPDetails(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountA,\n        uint256 _amountB,\n        uint256 _maxDiff,\n        address _poolContract\n    ) internal view returns (uint256, uint256) {\n        uint256 balanceA = IERC20(_tokenA).balanceOf(_poolContract);\n\n        // if it's a new pool we are initializing\n        if (balanceA == 0) {\n            return (_amountA, _amountB);\n        }\n        // otherwise, get all balances\n        uint256 balanceB = IERC20(_tokenB).balanceOf(_poolContract);\n\n        // get ratio between the two values\n        // 10^36 basically addds 18 decimals to the amount to\n        // account for values below 1. This still leaves\n        // us with max values of 10^41 before we overflow\n        // which is clearly enough\n        uint256 ratio = (balanceA * 10**36) / balanceB;\n        uint256 desiredRatio = (_amountA * 10**36) / _amountB;\n\n        // ratioDiff = ((big*1000000)/small)-1000000\n        // max ratio is defined in percent is\n        // basis points, so 1% = 100 and\n        // 100% = 10000\n\n        if (desiredRatio >= ratio) {\n            require(\n                ((desiredRatio * 1000000) / ratio) - 1000000 <= _maxDiff,\n                \"Module: ratio difference too big\"\n            );\n        } else {\n            require(\n                ((ratio * 1000000) / desiredRatio) - 1000000 <= _maxDiff,\n                \"Module: ratio difference too big\"\n            );\n        }\n\n        // if balanceA >= balanceB\n        if (ratio >= 10**18) {\n            return (_amountA, (_amountB * ratio) / 10**18);\n        } else {\n            return ((_amountA * ratio) / 10**18, _amountB);\n        }\n    }\n\n    /**\n      * @dev                    Distributes the LP tokens as well as any leftover tokens\n                                back to the DAOs based on their LP token shares\n      * @param _dealId              The ID of the action (position in the array)\n      * @param _la              The LiquidityPool object containg the information\n      * @param _lpToken         Address of the lp token\n      * @param _amount          Amount of lp tokens\n      * @param _leftOverAmounts Array of leftover amounts from the input tokens\n    */\n    function _distributeTokens(\n        uint32 _dealId,\n        LiquidityAction memory _la,\n        address _lpToken,\n        uint256 _amount,\n        uint256[] memory _leftOverAmounts\n    ) internal {\n        uint256[] memory daoShares = new uint256[](_la.daos.length);\n        uint256 amountsTo;\n        uint256 tokensLeft = _amount;\n\n        for (uint256 k; k < _la.pathTo.length >> 4; ++k) {\n            uint256 share;\n            // every 4 values, the values for a new dao start\n            // value 0 = instant amount\n            // value 1 = vested amount\n            // value 2 = vesting start\n            // value 3 = vesting end\n\n            // sending the vested amount first\n            if (_la.pathTo[(k << 2) + 1] > 0) {\n                share += _la.pathTo[(k << 2) + 1];\n                uint256 payout = (_amount * _la.pathTo[(k << 2) + 1]) / 10000;\n                amountsTo += payout;\n                tokensLeft -= payout;\n                payout = _payFeeAndReturnRemainder(_lpToken, payout);\n                _approveDaoDepositManager(_lpToken, _la.daos[k], payout);\n                IDaoDepositManager(\n                    dealManager.getDaoDepositManager(_la.daos[k])\n                ).startVesting(\n                        _dealId,\n                        _lpToken,\n                        payout, // amount\n                        uint32(_la.pathTo[(k << 2) + 2]), // start\n                        uint32(_la.pathTo[(k << 2) + 3]) // end\n                    );\n            }\n\n            // sending the instant amount\n            if (_la.pathTo[(k << 2)] > 0) {\n                share += _la.pathTo[(k << 2)];\n                uint256 payout = (_amount * _la.pathTo[(k << 2)]) / 10000;\n                amountsTo += payout;\n                tokensLeft -= payout;\n                // If we are at the last one, make sure that\n                // no dust is left behind\n                if (k == _la.daos.length - 1 && tokensLeft > 0) {\n                    payout += tokensLeft;\n                }\n                _transferWithFee(_lpToken, _la.daos[k], payout);\n            }\n            daoShares[k] = share;\n        }\n        require(amountsTo == _amount, \"Module: amount mismatch\");\n        _distributeLeftoverTokens(_dealId, daoShares, _leftOverAmounts);\n    }\n\n    /**\n      * @dev                    Distributes any leftover tokens back to the DAOs based on \n                                their LP token shares\n      * @param _dealId              The ID of the action (position in the array)\n      * @param _daoShares       Array of the percentage shares of each DAO for LP tokens\n                                  - In Basis Points (1% = 100) \n      * @param _amounts         Array of the amounts left for each input token\n    */\n    function _distributeLeftoverTokens(\n        uint32 _dealId,\n        uint256[] memory _daoShares,\n        uint256[] memory _amounts\n    ) internal {\n        require(\n            _daoShares.length == _amounts.length,\n            \"Module: array length mismatch\"\n        );\n        uint256[] memory left = _amounts;\n        for (uint256 i; i < _daoShares.length; ++i) {\n            for (uint256 j; j < _amounts.length; ++j) {\n                if (_amounts[j] > 0) {\n                    uint256 payout = (_amounts[j] * _daoShares[i]) / 10000;\n                    left[j] -= payout;\n                    // If we are at the last one, make sure that\n                    // no dust is left behind\n                    if (i == _daoShares.length - 1 && left[j] > 0) {\n                        payout += left[j];\n                    }\n                    _transfer(\n                        liquidityActions[_dealId].tokens[j],\n                        liquidityActions[_dealId].daos[i],\n                        payout\n                    );\n                }\n            }\n        }\n    }\n\n    modifier validId(uint32 _dealId) {\n        require(\n            _dealId < uint32(liquidityActions.length),\n            \"Module: id doesn't exist\"\n        );\n        _;\n    }\n\n    modifier isNotExecuted(uint32 _dealId) {\n        require(\n            !liquidityActions[_dealId].isExecuted,\n            \"Module: id has been executed\"\n        );\n        _;\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n}\n"
    },
    "contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.6.2;\n\nimport \"./IUniswapV2Router01.sol\";\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n"
    },
    "contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair,\n        uint256\n    );\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(address tokenA, address tokenB)\n        external\n        returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.5.0;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n}\n"
    },
    "contracts/modules/liquidity/balancer/LiquidityModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.9;\n\nimport \"../../ModuleBaseWithFee.sol\";\nimport \"../../../interfaces/IBalancerV2.sol\";\nimport \"../../../interfaces/IWETH.sol\";\n\n/**\n * @title PrimeDeals Liquidity Module (Balancer V2)\n * @dev   Smart contract to handle liquidity pool\n *        interactions for PrimeDeals\n */\ncontract LiquidityModule_Balancer is ModuleBaseWithFee {\n    IBalancerV2 public vault;\n\n    LiquidityAction[] public liquidityActions;\n\n    struct LiquidityAction {\n        // the participating DAOs\n        address[] daos;\n        // the tokens involved in the action\n        address[] tokens;\n        // the token flow from the DAOs to the module\n        uint256[][] pathFrom;\n        // the lp token flow from the module to the DAO\n        uint256[] pathTo;\n        // the maximum difference between the\n        // token ratio from pathFrom and the\n        // actual ratio on-chain in basis points\n        // (1% = 100)\n        uint256 maxDiff;\n        // unix timestamp of the deadline\n        uint32 deadline;\n        // unix timestamp of the execution\n        uint32 executionDate;\n        // status of the deal\n        bool isExecuted;\n    }\n\n    // pathFrom:\n    // how much tokens does each dao send to the module\n    // token -> dao -> amount\n    // [[123, 0, 123], [0, 123, 0]]\n    // token 1: dao 1 sends 123, dao 2 sends 0, dao 3 sends 123, etc.\n\n    // pathFrom:\n    // how much lp tokens does each dao receive\n    // from the module, includes vesting.\n    // since we do not know the amount of the LP tokens in any case\n    // we use percentage values here in basis points, so\n    // 1% = 100\n    // token -> dao -> tuple(4)\n    // [[instantAmount_dao1, vestedAmount_dao1, vestingStart_dao1,\n    // vestingEnd_dao1, instantAmount_dao2, ...], [...]]\n\n    event LiquidityActionCreated(\n        uint32 dealId,\n        address[] _daos,\n        address[] _tokens,\n        uint256[][] _pathFrom,\n        uint256[] _pathTo,\n        uint256 _maxDiff,\n        uint32 _deadline\n    );\n\n    event LiquidityActionCancelled(uint32 dealId);\n\n    event LiquidityActionDeadlineExtended(uint32 dealId, uint32 newDeadline);\n\n    event LiquidityActionExecuted(uint32 dealId);\n\n    constructor(address _dealManager, address _vault)\n        ModuleBaseWithFee(_dealManager)\n    {\n        require(_vault != address(0), \"Module: invalid vault address\");\n        vault = IBalancerV2(_vault);\n    }\n\n    /**\n      * @dev                Create a new liquidity pool related action\n      * @param _daos        Array containing the DAOs that are involed in this action\n      * @param _tokens      Array containing the tokens that are involed in this action\n      * @param _pathFrom    Two-dimensional array containing the tokens flowing from the\n                            DAOs into the module:\n                              - First array level is for each token\n                              - Second array level is for each dao\n                              - Contains absolute numbers of tokens\n      * @param _pathTo      Array containing the resulting LP tokens flowing to the DAOs\n                              - Contains percentage numbers of tokens\n                              - In Basis Points (1% = 100) \n      * @param _maxDiff     The maximum difference between the ratio resulting from the \n                            pathFrom and the actual balance of the pool (if it already \n                            exists)\n                              - In Basis Points (1% = 100) \n      * @param _deadline    Time until which this action can be executed (unix timestamp)\n      * @return             The ID of the new action\n    */\n    function createLiquidityAction(\n        address[] calldata _daos,\n        address[] calldata _tokens,\n        uint256[][] calldata _pathFrom,\n        uint256[] calldata _pathTo,\n        uint256 _maxDiff,\n        uint32 _deadline\n    ) public returns (uint32) {\n        require(_daos.length >= 2, \"Module: at least 2 daos required\");\n\n        require(\n            _tokens.length >= 2,\n            \"Module: only at least two tokens supported\"\n        );\n\n        require(_maxDiff <= 10000, \"Module: maxDiff can't be more than 100%\");\n\n        require(\n            _pathFrom.length == _pathTo.length &&\n                _pathFrom[0].length == _daos.length &&\n                _pathTo.length >> 2 == _daos.length,\n            \"Module: invalid array lengths\"\n        );\n\n        require(_deadline > block.timestamp, \"Module: invalid deadline\");\n\n        LiquidityAction memory la = LiquidityAction(\n            _daos,\n            _tokens,\n            _pathFrom,\n            _pathTo,\n            _maxDiff,\n            _deadline,\n            0,\n            false\n        );\n        liquidityActions.push(la);\n        uint32 dealId = uint32(liquidityActions.length - 1);\n\n        emit LiquidityActionCreated(\n            dealId,\n            _daos,\n            _tokens,\n            _pathFrom,\n            _pathTo,\n            _maxDiff,\n            _deadline\n        );\n        return dealId;\n    }\n\n    /**\n      * @dev                Create a new liquidity pool related action and automatically\n                            creates Deposit Contracts for each DAO that does not have one\n      * @param _daos        Array containing the DAOs that are involed in this action\n      * @param _tokens      Array containing the tokens that are involed in this action\n      * @param _pathFrom    Two-dimensional array containing the tokens flowing from the\n                            DAOs into the module:\n                              - First array level is for each token\n                              - Second array level is for each dao\n                              - Contains absolute numbers of tokens\n      * @param _pathTo      Array containing the resulting LP tokens flowing to the DAOs\n                              - Contains percentage numbers of tokens\n                              - In Basis Points (1% = 100) \n      * @param _maxDiff     The maximum difference between the ratio resulting from the \n                            pathFrom and the actual balance of the pool (if it already \n                            exists)\n                              - In Basis Points (1% = 100) \n      * @param _deadline    Time until which this action can be executed (unix timestamp)\n      * @return             The ID of the new action\n    */\n    function createDepositContractsAndCreateLiquidityAction(\n        address[] calldata _daos,\n        address[] calldata _tokens,\n        uint256[][] calldata _pathFrom,\n        uint256[] calldata _pathTo,\n        uint256 _maxDiff,\n        uint32 _deadline\n    ) external returns (uint32) {\n        for (uint256 i; i < _daos.length; ++i) {\n            if (!dealManager.hasDaoDepositManager(_daos[i])) {\n                dealManager.createDaoDepositManager(_daos[i]);\n            }\n        }\n\n        return\n            createLiquidityAction(\n                _daos,\n                _tokens,\n                _pathFrom,\n                _pathTo,\n                _maxDiff,\n                _deadline\n            );\n    }\n\n    /**\n      * @dev            Checks whether a liquidity action can be executed\n                        (which is the case if all DAOs have deposited)\n      * @param _dealId      The ID of the action (position in the array)\n      * @return         A bool flag indiciating whether the action can be executed\n    */\n    function checkExecutability(uint32 _dealId)\n        external\n        view\n        validId(_dealId)\n        returns (bool)\n    {\n        LiquidityAction memory la = liquidityActions[_dealId];\n        if (la.isExecuted) {\n            return false;\n        }\n\n        if (la.deadline < uint32(block.timestamp)) {\n            return false;\n        }\n\n        for (uint256 i; i < la.tokens.length; ++i) {\n            for (uint256 j; j < la.pathFrom[i].length; ++j) {\n                if (\n                    IDaoDepositManager(\n                        dealManager.getDaoDepositManager(la.daos[j])\n                    ).getAvailableDealBalance(\n                            address(this),\n                            _dealId,\n                            la.tokens[i]\n                        ) < la.pathFrom[i][j]\n                ) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev            Executes a liquidity action\n     * @param _dealId      The ID of the action (position in the array)\n     */\n    function executeLiquidityAction(uint32 _dealId)\n        external\n        validId(_dealId)\n        isNotExecuted(_dealId)\n    {\n        LiquidityAction memory la = liquidityActions[_dealId];\n\n        require(\n            la.deadline >= uint32(block.timestamp),\n            \"Module: action expired\"\n        );\n\n        // Collect tokens into the module\n        uint256[] memory tokenAmountsIn = _pullTokensIntoModule(\n            _dealId,\n            la.daos,\n            la.tokens,\n            la.pathFrom\n        );\n\n        for (uint256 i; i < la.tokens.length; ++i) {\n            if (la.tokens[i] == address(0)) {\n                address weth = dealManager.weth();\n                IWETH(weth).deposit{value: tokenAmountsIn[i]}();\n                la.tokens[i] = weth;\n            }\n            _approveToken(la.tokens[i], address(vault), tokenAmountsIn[i]);\n        }\n\n        IAsset[] memory assets = new IAsset[](la.tokens.length);\n        for (uint256 i; i < la.tokens.length; ++i) {\n            assets[i] = IAsset(la.tokens[i]);\n        }\n\n        // find pool or create pool\n        // get pool id\n        IBalancerV2.JoinPoolRequest memory joinPoolRequest = IBalancerV2\n            .JoinPoolRequest(\n                assets,\n                tokenAmountsIn,\n                abi.encode(0, tokenAmountsIn),\n                false\n            );\n\n        // IBalancerV2.joinPool(id, address(this), address(this), joinPoolRequest);\n\n        // TODO: add logic for balancer v2\n\n        la.isExecuted = true;\n        la.executionDate = uint32(block.timestamp);\n        emit LiquidityActionExecuted(_dealId);\n    }\n\n    /**\n      * @dev                Distributes the LP tokens as well as any leftover tokens\n                            back to the DAOs based on their LP token shares\n      * @param _dealId          The ID of the action (position in the array)\n      * @param _la          The LiquidityPool object containg the information\n      * @param _lpToken     Address of the lp token\n      * @param _amount      Amount of lp tokens\n      * @return _daoShares  The percentage share of each DAO for the lp tokens\n                            in basis points (1% = 100)\n    */\n    function _distributeLPTokens(\n        uint32 _dealId,\n        LiquidityAction memory _la,\n        address _lpToken,\n        uint256 _amount\n    ) internal returns (uint256[] memory _daoShares) {\n        uint256 amountsTo;\n        uint256 tokensLeft = _amount;\n        _daoShares = new uint256[](_la.daos.length);\n\n        for (uint256 k; k < _la.pathTo.length >> 2; ++k) {\n            uint256 share;\n            // every 4 values, the values for a new dao start\n            // value 0 = instant amount\n            // value 1 = vested amount\n            // value 2 = vesting start\n            // value 3 = vesting end\n\n            // sending the vested amount first\n            if (_la.pathTo[(k << 2) + 1] > 0) {\n                share += _la.pathTo[(k << 2) + 1];\n                uint256 payout = (_amount * _la.pathTo[(k << 2) + 1]) / 10000;\n                amountsTo += payout;\n                tokensLeft -= payout;\n                payout = _payFeeAndReturnRemainder(_lpToken, payout);\n                _approveDaoDepositManager(_lpToken, _la.daos[k], payout);\n                IDaoDepositManager(\n                    dealManager.getDaoDepositManager(_la.daos[k])\n                ).startVesting(\n                        _dealId,\n                        _lpToken,\n                        payout, // amount\n                        uint32(_la.pathTo[(k << 2) + 2]), // start\n                        uint32(_la.pathTo[(k << 2) + 3]) // end\n                    );\n            }\n\n            // sending the instant amount\n            if (_la.pathTo[(k << 2)] > 0) {\n                share += _la.pathTo[(k << 2)];\n                uint256 payout = (_amount * _la.pathTo[(k << 2)]) / 10000;\n                amountsTo += payout;\n                tokensLeft -= payout;\n                // If we are at the last one, make sure that\n                // no dust is left behind\n                if (k == _la.daos.length - 1 && tokensLeft > 0) {\n                    payout += tokensLeft;\n                }\n                _transferWithFee(_lpToken, _la.daos[k], payout);\n            }\n            _daoShares[k] = share;\n        }\n        require(amountsTo == _amount, \"Module: amount mismatch\");\n    }\n\n    /**\n      * @dev                    Distributes any leftover tokens back to the DAOs based on \n                                their LP token shares\n      * @param _dealId              The ID of the action (position in the array)\n      * @param _daoShares       Array of the percentage shares of each DAO for LP tokens\n                                  - In Basis Points (1% = 100) \n      * @param _amounts         Array of the amounts left for each input token\n    */\n    function _distributeLeftoverTokens(\n        uint32 _dealId,\n        uint256[] memory _daoShares,\n        uint256[] memory _amounts\n    ) internal {\n        require(\n            _daoShares.length == _amounts.length,\n            \"Module: array length mismatch\"\n        );\n        uint256[] memory left = _amounts;\n        for (uint256 i; i < _daoShares.length; ++i) {\n            for (uint256 j; j < _amounts.length; ++j) {\n                if (_amounts[j] > 0) {\n                    uint256 payout = (_amounts[j] * _daoShares[i]) / 10000;\n                    left[j] -= payout;\n                    // If we are at the last one, make sure that\n                    // no dust is left behind\n                    if (i == _daoShares.length - 1 && left[j] > 0) {\n                        payout += left[j];\n                    }\n                    _transfer(\n                        liquidityActions[_dealId].tokens[j],\n                        liquidityActions[_dealId].daos[i],\n                        payout\n                    );\n                }\n            }\n        }\n    }\n\n    modifier validId(uint32 _dealId) {\n        require(\n            _dealId < uint32(liquidityActions.length),\n            \"Module: id doesn't exist\"\n        );\n        _;\n    }\n\n    modifier isNotExecuted(uint32 _dealId) {\n        require(\n            !liquidityActions[_dealId].isExecuted,\n            \"Module: id has been executed\"\n        );\n        _;\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n}\n"
    },
    "contracts/interfaces/IBalancerV2.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.6.2;\n\ninterface IAsset {\n    // solhint-disable-previous-line no-empty-blocks\n}\n\ninterface IBalancerV2 {\n    function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external payable;\n\n    struct JoinPoolRequest {\n        IAsset[] assets;\n        uint256[] maxAmountsIn;\n        bytes userData;\n        bool fromInternalBalance;\n    }\n}\n"
    },
    "contracts/modules/jointventure/JointVenture.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/IGnosisSafe.sol\";\nimport \"../../interfaces/IDealManager.sol\";\nimport \"../../interfaces/IWETH.sol\";\nimport \"../ModuleBase.sol\";\n\n/**\n * @title PrimeDeals Joint Venture Module\n * @dev   Smart contract to handle joint venture\n *        interactions for PrimeDeals\n */\ncontract JointVentureModule is ModuleBase {\n    address public proxyFactory;\n    address public masterCopy;\n\n    JointVenture[] public jointVentures;\n\n    struct JointVenture {\n        // the participating DAOs\n        address[] daos;\n        // the members of the new safe\n        address[] safeMembers;\n        // the voting threshold of the\n        // new safe\n        uint32 safeThreshold;\n        // the tokens involved in the action\n        address[] tokens;\n        // the token flow from the DAOs to the module\n        uint256[][] pathFrom;\n        // unix timestamp of the deadline\n        uint32 deadline;\n        // unix timestamp of the execution\n        uint32 executionDate;\n        // status of the deal\n        bool isExecuted;\n    }\n\n    // pathFrom:\n    // how much tokens does each dao send to the module\n    // token -> dao -> amount\n    // [[123, 0, 123], [0, 123, 0]]\n    // token 1: dao 1 sends 123, dao 2 sends 0, dao 3 sends 123, etc.\n\n    event JointVentureActionCreated(\n        uint32 dealId,\n        address[] _daos,\n        address[] _safeMembers,\n        uint32 _safeThreshold,\n        address[] _tokens,\n        uint256[][] _pathFrom,\n        uint32 _deadline\n    );\n\n    event JointVentureActionCancelled(uint32 dealId);\n\n    event JointVentureActionExecuted(uint32 dealId);\n\n    constructor(\n        address _dealManager,\n        address _proxyFactory,\n        address _masterCopy\n    ) ModuleBase(_dealManager) {\n        require(\n            _proxyFactory != address(0),\n            \"Module: invalid proxy factory address\"\n        );\n        proxyFactory = _proxyFactory;\n        require(\n            _masterCopy != address(0),\n            \"Module: invalid master copy address\"\n        );\n        masterCopy = _masterCopy;\n    }\n\n    /**\n      * @dev                    Create a new joint venture action\n      * @param _daos            Array containing the DAOs that are involed in this action\n      * @param _safeMembers     Array containing the new safe members\n      * @param _safeThreshold   Voting threshold of the new safe\n      * @param _tokens          Array containing the tokens that are involed in this action\n      * @param _pathFrom        Two-dimensional array containing the tokens flowing from the\n                                DAOs into the module:\n                                  - First array level is for each token\n                                  - Second array level is for each dao\n                                  - Contains absolute numbers of tokens\n     \n      * @param _deadline        Time until which this action can be executed (unix timestamp)\n      * @return                 The dealId of the new action\n    */\n    function createJointVentureAction(\n        address[] calldata _daos,\n        address[] calldata _safeMembers,\n        uint32 _safeThreshold,\n        address[] calldata _tokens,\n        uint256[][] calldata _pathFrom,\n        uint32 _deadline\n    ) public returns (uint32) {\n        require(_daos.length >= 2, \"Module: at least 2 daos required\");\n\n        require(\n            _safeMembers.length != 0 && _tokens.length != 0,\n            \"Module: invalid inputs\"\n        );\n\n        require(\n            _safeThreshold != 0 &&\n                _safeThreshold <= uint32(_safeMembers.length),\n            \"Module: invalid safe threshold\"\n        );\n\n        JointVenture memory jv = JointVenture(\n            _daos,\n            _safeMembers,\n            _safeThreshold,\n            _tokens,\n            _pathFrom,\n            _deadline,\n            0,\n            false\n        );\n        jointVentures.push(jv);\n        uint32 dealId = uint32(jointVentures.length - 1);\n\n        emit JointVentureActionCreated(\n            dealId,\n            _daos,\n            _safeMembers,\n            _safeThreshold,\n            _tokens,\n            _pathFrom,\n            _deadline\n        );\n\n        return dealId;\n    }\n\n    /**\n      * @dev                    Create a new joint venture action and automatically\n                                creates Deposit Contracts for each DAO that does not have one\n      * @param _daos            Array containing the DAOs that are involed in this action\n      * @param _safeMembers     Array containing the new safe members\n      * @param _safeThreshold   Voting threshold of the new safe\n      * @param _tokens          Array containing the tokens that are involed in this action\n      * @param _pathFrom        Two-dimensional array containing the tokens flowing from the\n                                DAOs into the module:\n                                  - First array level is for each token\n                                  - Second array level is for each dao\n                                  - Contains absolute numbers of tokens\n     \n      * @param _deadline        Time until which this action can be executed (unix timestamp)\n      * @return                 The dealId of the new action\n    */\n    function createDepositContractsAndCreateJointVentureAction(\n        address[] calldata _daos,\n        address[] calldata _safeMembers,\n        uint32 _safeThreshold,\n        address[] calldata _tokens,\n        uint256[][] calldata _pathFrom,\n        uint32 _deadline\n    ) external returns (uint32) {\n        for (uint256 i; i < _daos.length; ++i) {\n            if (!dealManager.hasDaoDepositManager(_daos[i])) {\n                dealManager.createDaoDepositManager(_daos[i]);\n            }\n        }\n        return\n            createJointVentureAction(\n                _daos,\n                _safeMembers,\n                _safeThreshold,\n                _tokens,\n                _pathFrom,\n                _deadline\n            );\n    }\n\n    /**\n      * @dev            Checks whether a joint venture action can be executed\n                        (which is the case if all DAOs have deposited)\n      * @param _dealId  The ID of the action (position in the array)\n      * @return         A bool flag indiciating whether the action can be executed\n    */\n    function checkExecutability(uint32 _dealId)\n        external\n        view\n        validId(_dealId)\n        returns (bool)\n    {\n        JointVenture storage jv = jointVentures[_dealId];\n\n        if (jv.isExecuted) {\n            return false;\n        }\n\n        if (jv.deadline < uint32(block.timestamp)) {\n            return false;\n        }\n        for (uint256 i; i < jv.tokens.length; ++i) {\n            for (uint256 j; j < jv.pathFrom[i].length; ++j) {\n                // for each token and each pathFrom entry for this\n                // token, check whether the corresponding DAO\n                // has deposited the corresponding amount into their\n                // deposit contract\n                if (\n                    IDaoDepositManager(\n                        dealManager.getDaoDepositManager(jv.daos[j])\n                    ).getAvailableDealBalance(\n                            address(this),\n                            _dealId,\n                            jv.tokens[i]\n                        ) < jv.pathFrom[i][j]\n                ) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev            Executes a joint venture action\n     * @param _dealId      The ID of the action (position in the array)\n     */\n    function executeJointVentureAction(uint32 _dealId)\n        external\n        validId(_dealId)\n        isNotExecuted(_dealId)\n    {\n        JointVenture memory jv = jointVentures[_dealId];\n\n        require(jv.deadline >= block.timestamp, \"Module: action expired\");\n\n        // collect tokens into the module\n        uint256[] memory tokenAmountsIn = _pullTokensIntoModule(\n            _dealId,\n            jv.daos,\n            jv.tokens,\n            jv.pathFrom\n        );\n\n        // deploy the new gnosis safe with the parameters\n        address payable safe = _deploySafe(jv.safeMembers, jv.safeThreshold);\n\n        // send the collected funds to thew new safe\n        _sendFundsToSafe(safe, jv.tokens, tokenAmountsIn);\n\n        jv.isExecuted = true;\n        jv.executionDate = uint32(block.timestamp);\n        emit JointVentureActionExecuted(_dealId);\n    }\n\n    /**\n     * @dev                     Deploys the Gnosis Safe\n     * @param _safeMembers      Array of the addresses owning the new safe\n     * @param _safeThreshold    Voting Threshold of the new safe\n     * @return                  The address of the newly deployed safe\n     */\n    function _deploySafe(address[] memory _safeMembers, uint32 _safeThreshold)\n        internal\n        returns (address payable)\n    {\n        bytes memory safeInitData = abi.encodeWithSelector(\n            GnosisSafeSetup.setup.selector,\n            _safeMembers, // safe owners\n            _safeThreshold, // threshold\n            address(0x0), // to (for callback)\n            new bytes(0), // data (for callback)\n            address(0x0), // handler (for callback)\n            address(0x0), // payment token (for gasless creation)\n            0, // payment amount (for gasless creation)\n            address(0x0) // payment receiver (for gasless creation)\n        );\n\n        address payable safe = ProxyFactory(proxyFactory).createProxy(\n            masterCopy,\n            safeInitData\n        );\n\n        require(safe != address(0x0), \"Module: safe deployment failed\");\n        return safe;\n    }\n\n    /**\n     * @dev             Sends the collected funds to the new safe\n     * @param _safe     Address of the new safe\n     * @param _tokens   Array of token addresses\n     * @param _amounts  Array of amounts for each token to be sent\n     */\n    function _sendFundsToSafe(\n        address payable _safe,\n        address[] memory _tokens,\n        uint256[] memory _amounts\n    ) internal {\n        for (uint256 i; i < _tokens.length; ++i) {\n            if (_tokens[i] != address(0)) {\n                _transfer(_tokens[i], _safe, _amounts[i]);\n            } else {\n                IWETH(dealManager.weth()).withdraw(_amounts[i]);\n                (bool sent, ) = _safe.call{value: _amounts[i]}(\"\");\n                require(sent, \"Module: failed to send ether to new safe\");\n            }\n        }\n    }\n\n    modifier validId(uint32 _dealId) {\n        require(\n            _dealId <= uint32(jointVentures.length),\n            \"Module: id doesn't exist\"\n        );\n        _;\n    }\n\n    modifier isNotExecuted(uint32 _dealId) {\n        require(\n            !jointVentures[_dealId].isExecuted,\n            \"Module: id has been executed\"\n        );\n        _;\n    }\n}\n"
    },
    "contracts/interfaces/IGnosisSafe.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.6.2;\n\ninterface GnosisSafeSetup {\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    ) external;\n}\n\ninterface ProxyFactory {\n    function createProxy(address masterCopy, bytes calldata data)\n        external\n        returns (address payable proxy);\n}\n"
    },
    "contracts/modules/BlueprintModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.9;\n\nimport \"./ModuleBase.sol\";\nimport \"../interfaces/IDealManager.sol\";\n\ncontract BlueprintModule is ModuleBase {\n    Blueprint[] public blueprints;\n\n    struct Blueprint {\n        address[] daos;\n        uint256 value1;\n        address value2;\n        string value3;\n        uint256 executionDate;\n        bool isExecuted;\n    }\n\n    event ActionCreated(\n        uint256 id,\n        address[] _daos,\n        uint256 value1,\n        address value2,\n        string value3\n    );\n\n    event ActionCancelled(uint256 id);\n\n    event ActionExecuted(uint256 id);\n\n    constructor(address _dealManager)\n        ModuleBase(_dealManager)\n    // solhint-disable-next-line no-empty-blocks\n    {\n\n    }\n\n    function createAction(\n        address[] calldata _daos,\n        uint256 _value1,\n        address _value2,\n        string calldata _value3\n    ) public returns (uint256) {\n        require(_daos.length >= 2, \"Module: at least 2 daos required\");\n\n        require(\n            _value1 > 0 && _value2 != address(0) && bytes(_value3).length > 0,\n            \"Module: invalid inputs\"\n        );\n\n        Blueprint memory newBlueprint = Blueprint(\n            _daos,\n            _value1,\n            _value2,\n            _value3,\n            0,\n            false\n        );\n        blueprints.push(newBlueprint);\n        uint32 id = uint32(blueprints.length - 1);\n        emit ActionCreated(id, _daos, _value1, _value2, _value3);\n        return id;\n    }\n\n    function createDepositContractsAndCreateAction(\n        address[] calldata _daos,\n        uint256 _value1,\n        address _value2,\n        string calldata _value3\n    ) external returns (uint256) {\n        uint256 newId = createAction(_daos, _value1, _value2, _value3);\n        for (uint256 i; i < _daos.length; ++i) {\n            if (!dealManager.hasDaoDepositManager(_daos[i])) {\n                dealManager.createDaoDepositManager(_daos[i]);\n            }\n        }\n        return newId;\n    }\n\n    function checkExecutability(uint256 _id)\n        public\n        view\n        validId(_id)\n        returns (bool)\n    {\n        Blueprint storage blueprint = blueprints[_id];\n        if (blueprint.isExecuted) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function executeAction(uint256 _id)\n        external\n        validId(_id)\n        isNotExecuted(_id)\n    {\n        Blueprint memory blueprint = blueprints[_id];\n\n        require(\n            checkExecutability(_id),\n            \"Module: execution conditions not met\"\n        );\n\n        blueprint.isExecuted = true;\n        blueprint.executionDate = block.timestamp;\n        emit ActionExecuted(_id);\n    }\n\n    modifier validId(uint256 _id) {\n        require(_id < blueprints.length, \"Module: id doesn't exist\");\n        _;\n    }\n\n    modifier isNotExecuted(uint256 _id) {\n        require(!blueprints[_id].isExecuted, \"Module: has been executed\");\n        _;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "contracts/tests/TestToken.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract TestToken is ERC20 {\n    uint256 public constant MAX_SUPPLY = 1000000000 * 10**18; // 1 billion\n\n    constructor() ERC20(\"Test Token\", \"TT\") {\n        require(totalSupply() == 0, \"TT-ALREADY-INITIALIZED\");\n        _mint(msg.sender, MAX_SUPPLY);\n        require(totalSupply() == MAX_SUPPLY, \"TT-INVALID-SUPPLY\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Capped.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Capped.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\n\n/**\n * @dev Extension of {ERC20} that adds a cap to the supply of tokens.\n */\nabstract contract ERC20Capped is ERC20 {\n    uint256 private immutable _cap;\n\n    /**\n     * @dev Sets the value of the `cap`. This value is immutable, it can only be\n     * set once during construction.\n     */\n    constructor(uint256 cap_) {\n        require(cap_ > 0, \"ERC20Capped: cap is 0\");\n        _cap = cap_;\n    }\n\n    /**\n     * @dev Returns the cap on the token's total supply.\n     */\n    function cap() public view virtual returns (uint256) {\n        return _cap;\n    }\n\n    /**\n     * @dev See {ERC20-_mint}.\n     */\n    function _mint(address account, uint256 amount) internal virtual override {\n        require(ERC20.totalSupply() + amount <= cap(), \"ERC20Capped: cap exceeded\");\n        super._mint(account, amount);\n    }\n}\n"
    },
    "contracts/tests/PrimeToken.sol": {
      "content": "/*\n\n██████╗░██████╗░██╗███╗░░░███╗███████╗██████╗░░█████╗░░█████╗░\n██╔══██╗██╔══██╗██║████╗░████║██╔════╝██╔══██╗██╔══██╗██╔══██╗\n██████╔╝██████╔╝██║██╔████╔██║█████╗░░██║░░██║███████║██║░░██║\n██╔═══╝░██╔══██╗██║██║╚██╔╝██║██╔══╝░░██║░░██║██╔══██║██║░░██║\n██║░░░░░██║░░██║██║██║░╚═╝░██║███████╗██████╔╝██║░░██║╚█████╔╝\n╚═╝░░░░░╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝╚══════╝╚═════╝░╚═╝░░╚═╝░╚════╝░\n\n*/\n// SPDX-License-Identifier: GPL-3.0-or-later\n// solium-disable linebreak-style\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Capped.sol\";\n\ncontract PrimeToken is ERC20Capped {\n    constructor(\n        uint256 initialSupply,\n        uint256 cap,\n        address genesisMultisig\n    ) ERC20(\"Prime\", \"D2D\") ERC20Capped(cap) {\n        require(initialSupply <= cap); // _mint from ERC20 is not protected\n        ERC20._mint(genesisMultisig, initialSupply);\n    }\n}\n"
    },
    "contracts/tests/ERC20Mock.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract ERC20Mock is ERC20 {\n    uint256 public constant MAX_SUPPLY = 1000000000 * 10**18; // 1 billion\n\n    constructor(string memory _name, string memory _symbol)\n        ERC20(_name, _symbol)\n    {\n        require(totalSupply() == 0, \"ERC20-ALREADY-INITIALIZED\");\n        _mint(msg.sender, MAX_SUPPLY);\n        require(totalSupply() == MAX_SUPPLY, \"ERC20-INVALID-SUPPLY\");\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}